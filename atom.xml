<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yangyueren.github.io</id>
    <title>一只木头人</title>
    <updated>2021-10-03T06:49:36.318Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yangyueren.github.io"/>
    <link rel="self" href="https://yangyueren.github.io/atom.xml"/>
    <subtitle>每日一记</subtitle>
    <logo>https://yangyueren.github.io/images/avatar.png</logo>
    <icon>https://yangyueren.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 一只木头人</rights>
    <entry>
        <title type="html"><![CDATA[chapter3 线程间共享数据]]></title>
        <id>https://yangyueren.github.io/post/chapter3-xian-cheng-jian-gong-xiang-shu-ju/</id>
        <link href="https://yangyueren.github.io/post/chapter3-xian-cheng-jian-gong-xiang-shu-ju/">
        </link>
        <updated>2021-10-03T06:48:47.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.notion.so/chapter3-df92b90b9f794da5a459975defd57b45</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[chapter2 管理线程]]></title>
        <id>https://yangyueren.github.io/post/chapter2-guan-li-xian-cheng/</id>
        <link href="https://yangyueren.github.io/post/chapter2-guan-li-xian-cheng/">
        </link>
        <updated>2021-10-02T17:51:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="管理线程">管理线程</h1>
<h1 id="recall">Recall</h1>
<h3 id="传入thread的参数临时对象有什么问题">传入thread的参数？临时对象有什么问题？</h3>
<h3 id="线程detach引用了主线程的资源">线程detach引用了主线程的资源？</h3>
<h3 id="异常情况下何时调用join">异常情况下何时调用join？</h3>
<h3 id="stdthread-传入-引用">std::thread 传入 引用?</h3>
<p>std::bind? std::decay?</p>
<p>std::ref?</p>
<h3 id="转移线程所有权">转移线程所有权</h3>
<p>thread 是可以被move的，但是不能被copy</p>
<h3 id="比thread_guard更好的scoped_thread">比thread_guard更好的scoped_thread？</h3>
<p>好在哪里</p>
<h3 id="运行时选择线程数量">运行时选择线程数量?</h3>
<h1 id="notes">Notes</h1>
<h3 id="传入thread的参数临时对象有什么问题-2">传入thread的参数？临时对象有什么问题？</h3>
<ul>
<li>可以是一个重载了operator()的struct</li>
</ul>
<pre><code class="language-cpp">class background_task{
public:
	void operator() const{
		do_something();
	}
};
background_task f = background_task();
std::thread t(f);

</code></pre>
<pre><code class="language-cpp">//使用临时对象，容易报错
std::thread my_thread(background_task()); // 会解析为函数
//正确用法
std::thread my_thread((background_task()));
std::thread my_thread{background_task()};

</code></pre>
<h3 id="线程detach引用了主线程的资源-2">线程detach引用了主线程的资源？</h3>
<p>当线程被detach后，与主线程的生命周期分离，但是如果线程还在引用主线程里的变量，要小心主线程已经结束，释放了那些对象。</p>
<p>处理这种情况的通用做法是让线程函数自包含（译注：也就是函数本身什么都有，不需要依赖外部数据），将数据拷贝到线程中，而非共享数据。</p>
<h3 id="异常情况下何时调用join-2">异常情况下何时调用join？</h3>
<p>主线程调用子线程的join，要在主线程抛出异常前的对方调用。也需要在异常处理过程中调用join()，从而避免意外的生命周期问题。</p>
<ul>
<li>
<p>使用try catch</p>
<pre><code class="language-cpp">class background_task;
void f(){
	int local_var = 0;
	std::thread t({background_task()});
	try{
		do_something_in_current_thread();
	}catch(...){
		t.join();
		throw;
	}
	t.join();
}

</code></pre>
</li>
<li>
<p>使用RAII</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

struct func;

class thread_guard{

private:    
	  std::thread &amp;t;

public:
    explicit thread_guard(std::thread&amp; t): t(t){

    }
    ~thread_guard(){
        if(t.joinable()){
            t.join();
        }
    }
    thread_guard(const thread_guard&amp; t) = delete;
    thread_guard&amp; operator=(const thread_guard&amp;) = delete;

};

struct functor;
void f(){
    int local_state = 0;
    struct functor myfunc();
    std::thread t(myfunc);
    thread_guard g(t);
    do_some_thing_in_current_thread();
}
</code></pre>
</li>
</ul>
<h3 id="stdthread-传入-引用-2">std::thread 传入 引用?</h3>
<pre><code class="language-cpp">class widget{

};
void update_data(widget&amp; data);
void f2(){
    widget data;
    std::thread t(update_data, data); 
// 编译不通过，尽管update_data的第一个参数期待传入一个引用，
// 但是std::thread的构造函数并不知晓；                  
//构造函数无视函数期待的参数类型，并盲目地拷贝已提供的变量。
}

// 正确用法；类似std::bind
std::thread t(update_data_for_widget,w,std::ref(data));
/*
std::bind always copies its arguments, but callers can achieve the 
effect of having an argument stored by  reference by applying std::ref to it.
*/
</code></pre>
<p>Simply speaking, <strong>std::decay</strong> can remove references from type. For example, std::decay&lt;int&amp;&gt;::type is the same as just int. For std::thread and std::bind, when they store the parameters you passed in, std::decay<T>::type is used as the type for each of the parameters. Therefore, when a reference is passed in, a copy is created instead of simply storing a reference.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

using namespace std;

int main()
{
        int a = 0;
        int&amp; a_ref = a;
        decay&lt;int&amp;&gt;::type a_copy = a_ref;

        a_ref++;
        cout &lt;&lt; a &lt;&lt; endl;
        cout &lt;&lt; a_copy &lt;&lt; endl;
}
//output
/*
0
1
*/
</code></pre>
<p>std::ref 可以让引用变得 copyable</p>
<p>To overcome what <code>std::decay</code> does to references, we must have a copiable object which stores a reference internally. This is exactly what <code>[std::reference_wrapper](https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper)</code> does.</p>
<blockquote>
<p>std::reference_wrapper is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like std::vector) which cannot normally hold references.</p>
</blockquote>
<p><code>[std::ref](https://en.cppreference.com/w/cpp/utility/functional/ref)</code> is a handy function in the standard library to create a <code>std::reference_wrapper</code> object. With <code>std::ref</code>, we can finally pass references as parameters correctly as shown below (continuing the example above).</p>
<pre><code class="language-cpp">void inc(int&amp; x)
{
        x++;
        cout &lt;&lt; &quot;Inside inc, x is now &quot; &lt;&lt; x &lt;&lt; endl;
}
int main()
{
        int a = 0;
        int b = 0;

        auto func1 = bind(inc, a);
        func1();
        cout &lt;&lt; &quot;After func1, value of a is &quot; &lt;&lt; a &lt;&lt; endl;

        auto func2 = bind(inc, ref(b));
        func2();
        cout &lt;&lt; &quot;After func2, value of b is &quot; &lt;&lt; b &lt;&lt; endl;
}

/*output

Inside inc, x is now 1
After func1, value of a is 0
Inside inc, x is now 1
After func2, value of b is 1
*/

</code></pre>
<h3 id="转移线程所有权-2">转移线程所有权</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void func(){
    std::cout &lt;&lt; &quot;func&quot; &lt;&lt; std::endl;
}

int main(){
    std::thread t(func);
    std::thread&amp; g = t; //right
		// std::thread g = t; //wrong
    g.join();
    std::cout &lt;&lt; &quot;main&quot; &lt;&lt; std::endl;
}
</code></pre>
<h3 id="比thread_guard更好的scoped_thread-2">比thread_guard更好的scoped_thread？</h3>
<pre><code class="language-cpp">class scoped_thread{
private:
    std::thread t_;
public:
    scoped_thread(std::thread t): t_(std::move(t)){
        if(!t_.joinable()){
            throw std::logic_error(&quot;No thread&quot;);
        }
    }
    ~scoped_thread(){
        t_.join();
    }
    scoped_thread(const scoped_thread&amp;) = delete;
    scoped_thread&amp; operator=(const scoped_thread&amp;) = delete;
};
struct func;
void f(){
    int some_local_state = 0;
    scoped_thread s(std::thread(func(some_local_state)));
    do_some_thing_in_current_thread();
}
</code></pre>
<ul>
<li>避免了当thread_guard的生命周期长于它所引用的线程时引起不愉快的后果？</li>
<li>还意味着，一旦所有权转移到这个对象以后，没有谁能连接或者分离这个线程（因为thread_guard是传入一个引用，在main thread里仍然可以对那个thread进行操作，而scoped_thread是直接把thread move进scoped_thread对象里了）。</li>
</ul>
<h3 id="运行时选择线程数量-2">运行时选择线程数量?</h3>
<p>std::thread::hardware_concurrency()</p>
<p><strong>SUMMARY: 管理c++的线程，要注意thread不能copy，而且要考虑何时join(thread_guard, scoped_thread)</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[华为MindSpore数据集加载算子开发]]></title>
        <id>https://yangyueren.github.io/post/mindspore-development/</id>
        <link href="https://yangyueren.github.io/post/mindspore-development/">
        </link>
        <updated>2021-05-14T07:43:53.000Z</updated>
        <content type="html"><![CDATA[<p>MindData 是 MindSpore 的数据处理系统， 为 MindSpore 提供了数据加载和预处理管 道。在训练场景，MindData 负责将训练数据从文件系统加载到训练系统，通过数据处理管道， 进行一系列变换和数据增强，最终组成 Tensor，输入到计算框架进行前向和 反向计算。在推理场景，MindData将推理数据加载到内存，通过预定义的变换后，以 Tensor 形式输入给计算框架进行推理。</p>
<p>MindData支持python层和C++层API定义数据加载和数据处理流水线，MindData会运行Execution Tree，树上的每个节点对应数据处理流水线中的一步具体操作，例如在数据加载后有各种数据增强的Map算子、Repeat算子，本文将介绍最基本的数据集加载算子。<br>
一 个 完 整 的 数 据 处 理 算 子 包 含 四 部 分 ： 算 子 Op 实 现 、 算 子 IR （ Intermediate Representation）层定义、Python 层接口定义和 C++层接口定义。</p>
<h2 id="docker环境配置">docker环境配置</h2>
<pre><code>docker pull mindspore/mindspore-cpu:devel
docker run -it -p 8023:22 -p 10022:10022 --name=&quot;mindspore&quot; -v /home/docker_swap:/docker_swap mindspore/mindspore-cpu /bin/bash
</code></pre>
<p>进入docker后，下载mindspore代码，安装ssh和libboost-dev</p>
<pre><code>apt udpate
apt upgrade
apt-get install libboost-dev
apt-get install openssh-server //使用vscode连接docker进行开发

cd ~
git clone https://gitee.com/yangyueren/mindspore.git
</code></pre>
<p>编译</p>
<pre><code>cd mindspore

bash build.sh -e cpu –j24 –t on (wait for a long time)

pip install ./mindspore/build/package/mindspore-1.2.0-cp37-cp37m-linux_x86_64.whl

</code></pre>
<h2 id="数据集加载算子开发">数据集加载算子开发</h2>
<p>以places365数据集为例，详述数据集加载算子的开发过程。<br>
完整代码：https://gitee.com/yangyueren/mindspore/tree/op_places365/</p>
<p>新建分支</p>
<pre><code>git checkout –b places365_dataset
</code></pre>
<p>开发places365数据集加载算子需要修改或添加以下文件：</p>
<pre><code># 底层算子op开发，加载数据集的最底层的类
mindspore/ccsrc/minddata/dataset/engine/datasetops/source/CMakeLists.txt
mindspore/ccsrc/minddata/dataset/engine/datasetops/source/places365_op.cc
mindspore/ccsrc/minddata/dataset/engine/datasetops/source/places365_op.h


# 中间node表示层开发（IR层）
mindspore/ccsrc/minddata/dataset/engine/ir/datasetops/dataset_node.h
mindspore/ccsrc/minddata/dataset/engine/ir/datasetops/source/CMakeLists.txt
mindspore/ccsrc/minddata/dataset/engine/ir/datasetops/source/places365_node.cc
mindspore/ccsrc/minddata/dataset/engine/ir/datasetops/source/places365_node.h


# C++层API
mindspore/ccsrc/minddata/dataset/api/datasets.cc
mindspore/ccsrc/minddata/dataset/include/datasets.h
mindspore/ccsrc/minddata/dataset/include/samplers.h


# Python API，绑定到C++开发的算子上
mindspore/ccsrc/minddata/dataset/api/python/bindings/dataset/engine/datasetops/source/bindings.cc
mindspore/ccsrc/minddata/dataset/api/python/bindings/dataset/engine/ir/datasetops/source/bindings.cc

mindspore/dataset/engine/validators.py
mindspore/dataset/engine/datasets.py

</code></pre>
<h3 id="底层op算子开发">底层Op算子开发</h3>
<p>这里以places365数据集为例，Places365数据集包含365个场景，train-standard包含180万张图片，train-challenge包含800万张图片，val中包含36500张图片。<br>
Places365数据集提供了两套上述数据集，分别是高分辨率和256*256低分辨率图像。数据集格式如下：</p>
<pre><code>places365/                            // root directory of places365
|---categories_places365.txt          //两列，第一列是类别名，第二列是类别ID
|---places365_train-standard.txt      //两列，第一列是图片的路径，第二列是类别ID
|---places365_train-challenge.txt    //两列，第一列是图片的路径，第二列是类别ID
|---train_large_places365standard/   //存放train-standard高分辨率图片
|---train_large_places365challenge/  //存放train-challenge高分辨率图片
|---val_large/                       //存放val高分辨率图片
|---train_256_places365standard/     //存放train-standard低分辨率图片
|---train_256_places365standard/    //存放train-challenge低分辨率图片
|---val_256/                         //存放val低分辨率图片

</code></pre>
<p>本算子将读取数据集中的图片和label，将其封装为Tensor返回，列名为image和label。</p>
<p>在加载places365数据集时，需要指定以下参数：</p>
<pre><code>@param std::string root - root directory of places365
@param const std::string &amp;usage - Usage of this dataset, can be 'train-standard', 'train-challenge' or 'val'. Read the images in this folder and load this meta information.
@param bool small - Use high resolution images or 256*256 resolution images.
@param bool decode - Decode images

usage 决定了加载哪个数据集
usage 和 small参数共同决定了加载哪个文件夹、哪个分辨率大小的数据集
const std::map&lt;std::pair&lt;std::string, bool&gt;, std::string&gt; K_IMAGES_META = {
        {std::pair&lt;std::string, bool&gt;(&quot;train-standard&quot;, false), &quot;train_large_places365standard&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-challenge&quot;, false), &quot;train_large_places365challenge&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;val&quot;, false), &quot;val_large&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-standard&quot;, true), &quot;train_256_places365standard&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-challenge&quot;, true), &quot;train_256_places365challenge&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;val&quot;, true), &quot;val_256&quot;},
};
</code></pre>
<h4 id="源码分析">源码分析：</h4>
<p>由于places365数据集是可以random access的，也即给定一个下标，可以直接取出该下标的图片和label，所以在数据集加载时，用户可以自定义指定sampler（加载哪些下标数据集，比如只加载前300条数据，就没必要把places365所有的数据都读入到内存里，再返回前300条），所以Places365Op继承了RandomAccessOp，主要实现LoadBuffer里的LoadTensorRow函数，LoadTensorRow函数原型为Status Places365Op::LoadTensorRow(row_id_type row_id, TensorRow *trow)，将给定下标row_id的数据放入到trow里。</p>
<p>其余两个相关的函数分别为：<br>
Status WalkAllFiles(); 解析图片路径和label信息，不用加载图片到内存。<br>
Status LaunchThreadsAndInitOp(); 初始化。</p>
<p>数据集加载的算子逻辑是这样的，它一开始并不会加载图片到内存，它一开始只想知道一共有多少条数据，每个类别的数据对应的index是多少，所以Places365Op里有一个嵌套类Builder，Builder可以构造一个Places365Op，然后调用CountTotalRows函数来获取数据集的信息（注意，此时并不需要加载图片到内存，所以获取数据集的信息会非常快）。当获取了数据集的信息后（一共有多少条数据，每个类别的数据的下标），供给sampler使用，然后再构建Places365Op实例，并且指定要sample的数据的下标，进行数据的加载，这里使用到了多线程并行。<br>
归根结底，这里是将数据信息的加载（非常快）和数据本身的加载（加载全部会比较慢）分开了，可以让用户指定加载哪些数据，从而不用每次都加载全部，而是直接根据下标进行加载相应的数据集。</p>
<h4 id="places365_oph">places365_op.h</h4>
<pre><code>/**
 * Copyright 2019-2021 Huawei Technologies Co., Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MINDSPORE_CCSRC_MINDDATA_DATASET_ENGINE_DATASETOPS_SOURCE_PLACES365_OP_H_
#define MINDSPORE_CCSRC_MINDDATA_DATASET_ENGINE_DATASETOPS_SOURCE_PLACES365_OP_H_

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/core/utils/filesystem.hpp&gt;

#include &quot;minddata/dataset/core/tensor.h&quot;
#include &quot;minddata/dataset/engine/data_buffer.h&quot;
#include &quot;minddata/dataset/engine/data_schema.h&quot;
#include &quot;minddata/dataset/engine/datasetops/parallel_op.h&quot;
#include &quot;minddata/dataset/engine/datasetops/source/sampler/sampler.h&quot;
#include &quot;minddata/dataset/util/path.h&quot;
#include &quot;minddata/dataset/util/queue.h&quot;
#include &quot;minddata/dataset/util/status.h&quot;
#include &quot;minddata/dataset/util/wait_post.h&quot;

namespace mindspore {
namespace dataset {
// Forward declares
template &lt;typename T&gt;
class Queue;

using Places365LabelPair = std::pair&lt;std::shared_ptr&lt;Tensor&gt;, uint32_t&gt;;

class Places365Op : public ParallelOp, public RandomAccessOp {
 public:
  class Builder {
   public:
    // Constructor for Builder class of Places365Op
    Builder();

    // Destructor.
    ~Builder() = default;

    // Setter method
    // @param int32_t rows_per_buffer
    // @return Builder setter method returns reference to the builder.
    Builder &amp;SetRowsPerBuffer(int32_t rows_per_buffer) {
      builder_rows_per_buffer_ = rows_per_buffer;
      return *this;
    }

    // Setter method
    // @param int32_t op_connector_size
    // @return Builder setter method returns reference to the builder.
    Builder &amp;SetOpConnectorSize(int32_t op_connector_size) {
      builder_op_connector_size_ = op_connector_size;
      return *this;
    }

    // Setter method
    // @param int32_t num_workers
    // @return Builder setter method returns reference to the builder.
    Builder &amp;SetNumWorkers(int32_t num_workers) {
      builder_num_workers_ = num_workers;
      return *this;
    }

    // Setter method
    // @param std::shared_ptr&lt;Sampler&gt; sampler
    // @return Builder setter method returns reference to the builder.
    Builder &amp;SetSampler(std::shared_ptr&lt;SamplerRT&gt; sampler) {
      builder_sampler_ = std::move(sampler);
      return *this;
    }

    // Setter method
    // @param const std::string &amp;dir
    // @return
    Builder &amp;SetDir(const std::string &amp;dir) {
      builder_dir_ = dir;
      return *this;
    }

    // Setter method
    // @param const std::string &amp;usage
    // @return
    Builder &amp;SetUsage(const std::string &amp;usage) {
      builder_usage_ = usage;
      return *this;
    }

    // Setter method
    // @param bool small
    // @return
    Builder &amp;SetSmall(bool small) {
      builder_small_ = small;
      return *this;
    }
    // Setter method
    // @param bool decode
    // @return
    Builder &amp;SetDecode(bool decode) {
      builder_decode_ = decode;
      return *this;
    }


    // Check validity of input args
    // @return Status The status code returned
    Status SanityCheck();

    // The builder &quot;Build&quot; method creates the final object.
    // @param std::shared_ptr&lt;Places365Op&gt; *op - DatasetOp
    // @return Status The status code returned
    Status Build(std::shared_ptr&lt;Places365Op&gt; *op);

   private:
    std::string builder_dir_;
    std::string builder_usage_;
    bool builder_small_;
    bool builder_decode_;
    int32_t builder_num_workers_;
    int32_t builder_rows_per_buffer_;
    int32_t builder_op_connector_size_;
    std::shared_ptr&lt;SamplerRT&gt; builder_sampler_;
    std::unique_ptr&lt;DataSchema&gt; builder_schema_;
  };

  // Constructor
  // @param std::string root - dir directory of places365
  // @param const std::string &amp;usage - Usage of this dataset, can be 'train-standard', 'train-challenge' or 'val'
  // @param bool small - Use high resolution images or 256*256 resolution images
  // @param bool decode - Decode  jpg format images
  // @param int32_t num_workers - number of workers reading images in parallel
  // @param int32_t rows_per_buffer - number of images (rows) in each buffer
  // @param int32_t queue_size - connector queue size
  // @param std::unique_ptr&lt;DataSchema&gt; data_schema - the schema of the mnist dataset
  // @param td::unique_ptr&lt;Sampler&gt; sampler - sampler tells Places365Op what to read
  Places365Op(const std::string &amp;root, const std::string &amp;usage, bool small, bool decode, int32_t num_workers, int32_t rows_per_buffer, 
          int32_t queue_size, std::unique_ptr&lt;DataSchema&gt; data_schema, std::shared_ptr&lt;SamplerRT&gt; sampler);

  // Destructor.
  ~Places365Op() = default;

  // Worker thread pulls a number of IOBlock from IOBlock Queue, make a buffer and push it to Connector
  // @param int32_t worker_id - id of each worker
  // @return Status The status code returned
  Status WorkerEntry(int32_t worker_id) override;

  // Main Loop of Places365Op
  // Master thread: Fill IOBlockQueue, then goes to sleep
  // Worker thread: pulls IOBlock from IOBlockQueue, work on it then put buffer to mOutConnector
  // @return Status The status code returned
  Status operator()() override;

  // Method derived from RandomAccess Op, enable Sampler to get all ids for each class
  // @param (std::map&lt;uint64_t, std::vector&lt;uint64_t &gt;&gt; * map - key label, val all ids for this class
  // @return Status The status code returned
  Status GetClassIds(std::map&lt;int32_t, std::vector&lt;int64_t&gt;&gt; *cls_ids) const override;

  // A print method typically used for debugging
  // @param out
  // @param show_all
  void Print(std::ostream &amp;out, bool show_all) const override;

  // Function to count the number of samples in the Places365 dataset
  // @param dir path to the Places365 directory
  // @param const std::string &amp;usage - Usage of this dataset, can be 'train-standard', 'train-challenge' or 'val'
  // @param const bool small - Use high resolution images or 256*256 resolution images
  // @param const bool decode - Decode  jpg format images
  // @param count output arg that will hold the minimum of the actual dataset size and numSamples
  // @return
  static Status CountTotalRows(const std::string &amp;dir, const std::string &amp;usage, const bool small, const bool decode, int64_t *count);

  // Op name getter
  // @return Name of the current Op
  std::string Name() const override { return &quot;Places365Op&quot;; }

 private:
  // Initialize Sampler, calls sampler-&gt;Init() within
  // @return Status The status code returned
  Status InitSampler();

  // Load a tensor row according to a pair
  // @param row_id_type row_id - id for this tensor row
  // @param ImageLabelPair pair - &lt;imagefile,label&gt;
  // @param TensorRow row - image &amp; label read into this tensor row
  // @return Status The status code returned
  Status LoadTensorRow(row_id_type row_id, TensorRow *row);

  // @param const std::vector&lt;int64_t&gt; &amp;keys - keys in ioblock
  // @param std::unique_ptr&lt;DataBuffer&gt; db
  // @return Status The status code returned
  Status LoadBuffer(const std::vector&lt;int64_t&gt; &amp;keys, std::unique_ptr&lt;DataBuffer&gt; *db);

  // Iterate through all members in sampleIds and fill them into IOBlock.
  // @param std::shared_ptr&lt;Tensor&gt; sample_ids -
  // @param std::vector&lt;int64_t&gt; *keys - keys in ioblock
  // @return Status The status code returned
  Status TraversalSampleIds(const std::shared_ptr&lt;Tensor&gt; &amp;sample_ids, std::vector&lt;int64_t&gt; *keys);

  // Load the meta information of categories.
  // @param const std::string &amp;category_meta_name
  // @return Status The status code returned
  Status LoadCategories(const std::string &amp;category_meta_name);

  // Load the meta information of file infomation.
  // @param const std::string &amp;filelists_meta_name
  // @return Status The status code returned
  Status LoadFileLists(const std::string &amp;filelists_meta_name);

  // Get one piece of places365 data
  // @param uint32_t index Index of the datas
  // @param std::shared_ptr&lt;Tensor&gt; *image_tensor Store the result in image_tensor
  // @return Status The status code returned
  Status GetPlaces365DataTensor(uint32_t index, std::shared_ptr&lt;Tensor&gt; *image_tensor);

  // Read all files in the directory
  // @return Status The status code returned
  Status WalkAllFiles();

  // Called first when function is called
  // @return Status The status code returned
  Status LaunchThreadsAndInitOp();



  // reset Op
  // @return Status The status code returned
  Status Reset() override;

  // Private function for computing the assignment of the column name map.
  // @return - Status
  Status ComputeColMap() override;

  int64_t buf_cnt_;
  int64_t row_cnt_;
  int32_t rows_per_buffer_;
  std::unique_ptr&lt;DataSchema&gt; data_schema_;

  const std::string root_; // directory of image folder
  const std::string usage_; // can only be &quot;train-challenge&quot;, &quot;train-standard&quot; or &quot;val&quot;
  const bool small_;
  const bool decode_;

  std::map&lt;std::string, int&gt; categorie2id_;

  std::vector&lt;std::pair&lt;std::string, uint32_t&gt;&gt; image_path_label_pairs_;

  // std::vector&lt;Places365LabelPair&gt; image_label_pairs_;

};
}  // namespace dataset
}  // namespace mindspore
#endif  // MINDSPORE_CCSRC_MINDDATA_DATASET_ENGINE_DATASETOPS_SOURCE_PLACES365_OP_H_

</code></pre>
<h4 id="places365_opcc">places365_op.cc</h4>
<pre><code>/**
 * Copyright 2019-2021 Huawei Technologies Co., Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;minddata/dataset/engine/datasetops/source/places365_op.h&quot;

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;set&gt;
#include &quot;utils/ms_utils.h&quot;
#include &quot;minddata/dataset/core/config_manager.h&quot;
#include &quot;minddata/dataset/core/tensor_shape.h&quot;
#include &quot;minddata/dataset/engine/datasetops/source/sampler/sequential_sampler.h&quot;
#include &quot;minddata/dataset/engine/db_connector.h&quot;
#include &quot;minddata/dataset/engine/execution_tree.h&quot;
#ifndef ENABLE_ANDROID
#include &quot;minddata/dataset/kernels/image/image_utils.h&quot;
#else
#include &quot;minddata/dataset/kernels/image/lite_image_utils.h&quot;
#endif

namespace mindspore {
namespace dataset {
const std::string K_CATEGORIES_META = &quot;categories_places365.txt&quot;;
const std::map&lt;std::string, std::string&gt; K_FILE_LIST_META = {
    {&quot;train-standard&quot;, &quot;places365_train_standard.txt&quot;},
    {&quot;train-challenge&quot;, &quot;places365_train_challenge.txt&quot;},
    {&quot;val&quot;, &quot;places365_val.txt&quot;}
};
const std::map&lt;std::pair&lt;std::string, bool&gt;, std::string&gt; K_IMAGES_META = {
        {std::pair&lt;std::string, bool&gt;(&quot;train-standard&quot;, false), &quot;train_large_places365standard&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-challenge&quot;, false), &quot;train_large_places365challenge&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;val&quot;, false), &quot;val_large&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-standard&quot;, true), &quot;train_256_places365standard&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;train-challenge&quot;, true), &quot;train_256_places365challenge&quot;},
        {std::pair&lt;std::string, bool&gt;(&quot;val&quot;, true), &quot;val_256&quot;},
};

Places365Op::Builder::Builder() : builder_sampler_(nullptr), builder_usage_(&quot;train-standard&quot;), builder_small_(true), builder_decode_(true) {
  std::shared_ptr&lt;ConfigManager&gt; cfg = GlobalContext::config_manager();
  builder_num_workers_ = cfg-&gt;num_parallel_workers();
  builder_rows_per_buffer_ = cfg-&gt;rows_per_buffer();
  builder_op_connector_size_ = cfg-&gt;op_connector_size();
}

Status Places365Op::Builder::Build(std::shared_ptr&lt;Places365Op&gt; *ptr) {
  RETURN_IF_NOT_OK(SanityCheck());
  if (builder_sampler_ == nullptr) {
    const int64_t num_samples = 0;
    const int64_t start_index = 0;
    builder_sampler_ = std::make_shared&lt;SequentialSamplerRT&gt;(start_index, num_samples);
  }
  builder_schema_ = std::make_unique&lt;DataSchema&gt;();
  RETURN_IF_NOT_OK(
    builder_schema_-&gt;AddColumn(ColDescriptor(&quot;image&quot;, DataType(DataType::DE_UINT8), TensorImpl::kCv, 1)));
  TensorShape scalar = TensorShape::CreateScalar();
  RETURN_IF_NOT_OK(builder_schema_-&gt;AddColumn(
    ColDescriptor(&quot;label&quot;, DataType(DataType::DE_UINT32), TensorImpl::kFlexible, 0, &amp;scalar)));
  *ptr = std::make_shared&lt;Places365Op&gt;(builder_dir_, builder_usage_, builder_small_, builder_decode_, builder_num_workers_, builder_rows_per_buffer_,
                                   builder_op_connector_size_, std::move(builder_schema_), std::move(builder_sampler_));
  return Status::OK();
}

Status Places365Op::Builder::SanityCheck() {
  const std::set&lt;std::string&gt; valid = {&quot;train-standard&quot;, &quot;train-challenge&quot;, &quot;val&quot;};
  Path dir(builder_dir_);
  std::string err_msg;
  err_msg += dir.IsDirectory() == false
               ? &quot;Invalid parameter, MNIST path is invalid or not set, path: &quot; + builder_dir_ + &quot;.\n&quot;
               : &quot;&quot;;
  err_msg += builder_num_workers_ &lt;= 0 ? &quot;Invalid parameter, num_parallel_workers must be greater than 0, but got &quot; +
                                           std::to_string(builder_num_workers_) + &quot;.\n&quot;
                                       : &quot;&quot;;
  err_msg += valid.find(builder_usage_) == valid.end()
               ? &quot;Invalid parameter, usage must be 'train-standard', 'train-challenge', 'val', but got &quot; + builder_usage_ + &quot;.\n&quot;
               : &quot;&quot;;
  return err_msg.empty() ? Status::OK() : Status(StatusCode::kMDUnexpectedError, __LINE__, __FILE__, err_msg);
}

Places365Op::Places365Op(const std::string &amp;root, const std::string &amp;usage, bool small, bool decode, int32_t num_workers, int32_t rows_per_buffer, 
          int32_t queue_size, std::unique_ptr&lt;DataSchema&gt; data_schema, std::shared_ptr&lt;SamplerRT&gt; sampler)
    : ParallelOp(num_workers, queue_size, std::move(sampler)),
      root_(root),
      usage_(usage),
      small_(small),
      decode_(decode),
      buf_cnt_(0),
      row_cnt_(0),
      rows_per_buffer_(rows_per_buffer),
      categorie2id_({}),
      image_path_label_pairs_({}),
      data_schema_(std::move(data_schema)) {
  io_block_queues_.Init(num_workers, queue_size);
}

Status Places365Op::TraversalSampleIds(const std::shared_ptr&lt;Tensor&gt; &amp;sample_ids, std::vector&lt;int64_t&gt; *keys) {
  for (auto itr = sample_ids-&gt;begin&lt;int64_t&gt;(); itr != sample_ids-&gt;end&lt;int64_t&gt;(); ++itr) {
    if ((*itr) &gt;= num_rows_) continue;  // index out of bound, skipping
    keys-&gt;push_back(*itr);
    row_cnt_++;
    if (row_cnt_ % rows_per_buffer_ == 0) {
      RETURN_IF_NOT_OK(io_block_queues_[buf_cnt_++ % num_workers_]-&gt;Add(
        std::make_unique&lt;IOBlock&gt;(IOBlock(*keys, IOBlock::kDeIoBlockNone))));
      keys-&gt;clear();
    }
  }
  return Status::OK();
}

// functor that contains the main logic of Places365 op
Status Places365Op::operator()() {
  RETURN_IF_NOT_OK(LaunchThreadsAndInitOp());
  std::unique_ptr&lt;DataBuffer&gt; sampler_buffer;
  RETURN_IF_NOT_OK(sampler_-&gt;GetNextSample(&amp;sampler_buffer));
  while (true) {  // each iterator is 1 epoch
    std::vector&lt;int64_t&gt; keys;
    keys.reserve(rows_per_buffer_);
    while (sampler_buffer-&gt;eoe() == false) {
      std::shared_ptr&lt;Tensor&gt; sample_ids;
      RETURN_IF_NOT_OK(sampler_buffer-&gt;GetTensor(&amp;sample_ids, 0, 0));
      if (sample_ids-&gt;type() != DataType(DataType::DE_INT64)) {
        RETURN_STATUS_UNEXPECTED(&quot;Invalid parameter, data type of Sampler Tensor isn't int64, got &quot; +
                                 sample_ids-&gt;type().ToString());
      }
      RETURN_IF_NOT_OK(TraversalSampleIds(sample_ids, &amp;keys));
      RETURN_IF_NOT_OK(sampler_-&gt;GetNextSample(&amp;sampler_buffer));
    }
    if (keys.empty() == false) {
      RETURN_IF_NOT_OK(io_block_queues_[(buf_cnt_++) % num_workers_]-&gt;Add(
        std::make_unique&lt;IOBlock&gt;(IOBlock(keys, IOBlock::kDeIoBlockNone))));
    }
    if (IsLastIteration()) {
      RETURN_IF_NOT_OK(
        io_block_queues_[(buf_cnt_++) % num_workers_]-&gt;Add(std::make_unique&lt;IOBlock&gt;(IOBlock::kDeIoBlockFlagEoe)));
      RETURN_IF_NOT_OK(
        io_block_queues_[(buf_cnt_++) % num_workers_]-&gt;Add(std::make_unique&lt;IOBlock&gt;(IOBlock::kDeIoBlockFlagEof)));
      for (int32_t i = 0; i &lt; num_workers_; ++i) {
        RETURN_IF_NOT_OK(
          io_block_queues_[i]-&gt;Add(std::make_unique&lt;IOBlock&gt;(std::vector&lt;int64_t&gt;(), IOBlock::kDeIoBlockNone)));
      }
      return Status::OK();
    } else {
      RETURN_IF_NOT_OK(
        io_block_queues_[(buf_cnt_++) % num_workers_]-&gt;Add(std::make_unique&lt;IOBlock&gt;(IOBlock::kDeIoBlockFlagEoe)));
    }

    if (epoch_sync_flag_) {
      // If epoch_sync_flag_ is set, then master thread sleeps until all the worker threads have finished their job for
      // the current epoch.
      RETURN_IF_NOT_OK(WaitForWorkers());
    }
    // If not the last repeat, self-reset and go to loop again.
    if (!IsLastIteration()) {
      RETURN_IF_NOT_OK(Reset());
      RETURN_IF_NOT_OK(sampler_-&gt;GetNextSample(&amp;sampler_buffer));
    }
    UpdateRepeatAndEpochCounter();
  }
}

// contains the logic of pulling a IOBlock from IOBlockQueue, load a buffer and push the buffer to out_connector_
Status Places365Op::WorkerEntry(int32_t worker_id) {
  TaskManager::FindMe()-&gt;Post();
  int64_t buffer_id = worker_id;
  std::unique_ptr&lt;IOBlock&gt; iOBlock;
  RETURN_IF_NOT_OK(io_block_queues_[worker_id]-&gt;PopFront(&amp;iOBlock));
  while (iOBlock != nullptr) {
    if (iOBlock-&gt;wait() == true) {
      // Sync io_block is a signal that master thread wants us to pause and sync with other workers.
      // The last guy who comes to this sync point should reset the counter and wake up the master thread.
      if (++num_workers_paused_ == num_workers_) {
        wait_for_workers_post_.Set();
      }
    } else if (iOBlock-&gt;eoe() == true) {
      RETURN_IF_NOT_OK(out_connector_-&gt;Add(worker_id, std::make_unique&lt;DataBuffer&gt;(0, DataBuffer::kDeBFlagEOE)));
      buffer_id = worker_id;
    } else if (iOBlock-&gt;eof() == true) {
      RETURN_IF_NOT_OK(out_connector_-&gt;Add(worker_id, std::make_unique&lt;DataBuffer&gt;(0, DataBuffer::kDeBFlagEOF)));
    } else {
      std::vector&lt;int64_t&gt; keys;
      RETURN_IF_NOT_OK(iOBlock-&gt;GetKeys(&amp;keys));
      if (keys.empty() == true) return Status::OK();  // empty key is a quit signal for workers
      std::unique_ptr&lt;DataBuffer&gt; db = std::make_unique&lt;DataBuffer&gt;(buffer_id, DataBuffer::kDeBFlagNone);
      RETURN_IF_NOT_OK(LoadBuffer(keys, &amp;db));
      RETURN_IF_NOT_OK(out_connector_-&gt;Add(worker_id, std::move(db)));
      buffer_id += num_workers_;
    }
    RETURN_IF_NOT_OK(io_block_queues_[worker_id]-&gt;PopFront(&amp;iOBlock));
  }
  RETURN_STATUS_UNEXPECTED(&quot;Unexpected nullptr received in worker.&quot;);
}

Status Places365Op::LoadTensorRow(row_id_type row_id, TensorRow *trow) {
  std::shared_ptr&lt;Tensor&gt; image, label;
  // make a copy of cached tensor
  RETURN_IF_NOT_OK(GetPlaces365DataTensor(row_id, &amp;image));
  RETURN_IF_NOT_OK(Tensor::CreateScalar(image_path_label_pairs_[row_id].second, &amp;label));

  (*trow) = TensorRow(row_id, {std::move(image), std::move(label)});
  // trow-&gt;setPath({image_path_[row_id], label_path_[row_id]});
  return Status::OK();
}

// Looping over LoadTensorRow to make 1 DataBuffer. 1 function call produces 1 buffer
Status Places365Op::LoadBuffer(const std::vector&lt;int64_t&gt; &amp;keys, std::unique_ptr&lt;DataBuffer&gt; *db) {
  std::unique_ptr&lt;TensorQTable&gt; deq = std::make_unique&lt;TensorQTable&gt;();
  TensorRow trow;
  for (const int64_t &amp;key : keys) {
    RETURN_IF_NOT_OK(this-&gt;LoadTensorRow(key, &amp;trow));
    deq-&gt;push_back(std::move(trow));
  }
  (*db)-&gt;set_tensor_table(std::move(deq));
  return Status::OK();
}

void Places365Op::Print(std::ostream &amp;out, bool show_all) const {
  if (!show_all) {
    // Call the super class for displaying any common 1-liner info
    ParallelOp::Print(out, show_all);
    // Then show any custom derived-internal 1-liner info for this op
    out &lt;&lt; &quot;\n&quot;;
  } else {
    // Call the super class for displaying any common detailed info
    ParallelOp::Print(out, show_all);
    // Then show any custom derived-internal stuff
    out &lt;&lt; &quot;\nNumber of rows:&quot; &lt;&lt; num_rows_ &lt;&lt; &quot;\nPlaces365 Directory: &quot; &lt;&lt; root_ &lt;&lt; &quot;\n\n&quot;;
  }
}

// Reset Sampler and wakeup Master thread (functor)
Status Places365Op::Reset() {
  MS_LOG(DEBUG) &lt;&lt; Name() &lt;&lt; &quot; performing a self-reset.&quot;;
  RETURN_IF_NOT_OK(sampler_-&gt;ResetSampler());
  row_cnt_ = 0;
  return Status::OK();
}

// hand shake with Sampler, allow Sampler to call RandomAccessOp's functions to get NumRows
Status Places365Op::InitSampler() {
  RETURN_IF_NOT_OK(sampler_-&gt;HandshakeRandomAccessOp(this));
  return Status::OK();
}

// Derived from RandomAccessOp
Status Places365Op::GetClassIds(std::map&lt;int32_t, std::vector&lt;int64_t&gt;&gt; *cls_ids) const {
  if (cls_ids == nullptr || !cls_ids-&gt;empty() || image_path_label_pairs_.empty()) {
    if (image_path_label_pairs_.empty()) {
      RETURN_STATUS_UNEXPECTED(&quot;No image found in dataset, please check if Op read images successfully or not.&quot;);
    } else {
      RETURN_STATUS_UNEXPECTED(
        &quot;Map for storaging image-index pair is nullptr or has been set in other place,&quot;
        &quot;it must be empty before using GetClassIds.&quot;);
    }
  }
  for (size_t i = 0; i &lt; image_path_label_pairs_.size(); ++i) {
    (*cls_ids)[image_path_label_pairs_[i].second].push_back(i);
  }
  for (auto &amp;pair : (*cls_ids)) {
    pair.second.shrink_to_fit();
  }
  return Status::OK();
}

// Load the meta information of categories.
// @param const std::string &amp;category_meta_name
// @return Status The status code returned
Status Places365Op::LoadCategories(const std::string &amp;category_meta_name){
    std::ifstream reader(category_meta_name);
    // std::cout &lt;&lt; category_meta_name &lt;&lt; std::endl;
    CHECK_FAIL_RETURN_UNEXPECTED(!reader.fail(), category_meta_name + &quot; File not exists!&quot;);
    std::string path;
    int label;
    
    while (reader &gt;&gt; path &gt;&gt; label){
        categorie2id_.insert({path, label});
    }
    reader.close();
    return Status::OK();

}

// Load the meta information of file infomation.
// @param const std::string &amp;filelists_meta_name
// @return Status The status code returned
Status Places365Op::LoadFileLists(const std::string &amp;filelists_meta_name){
    // std::cout &lt;&lt; filelists_meta_name &lt;&lt; std::endl;
    std::ifstream reader(filelists_meta_name);
    CHECK_FAIL_RETURN_UNEXPECTED(!reader.fail(), filelists_meta_name + &quot; File not exists!&quot;);
    std::string path;
    int label;
    std::string folder_path = cv::utils::fs::join(root_, K_IMAGES_META.at(std::make_pair(usage_, small_)));
    image_path_label_pairs_.clear();
    while (reader &gt;&gt; path &gt;&gt; label){
        image_path_label_pairs_.push_back({cv::utils::fs::join(folder_path, path), label});
    }
    reader.close();
    return Status::OK();
}

// Get one piece of places365 data
// @param uint32_t index Index of the datas
// @param std::shared_ptr&lt;Tensor&gt; *image_tensor Store the result in image_tensor
// @return Status The status code returned
Status Places365Op::GetPlaces365DataTensor(uint32_t index, std::shared_ptr&lt;Tensor&gt; *image_tensor){

    std::string file_path = image_path_label_pairs_[index].first;

    RETURN_IF_NOT_OK(Tensor::CreateFromFile(file_path, image_tensor));
    if(decode_){
        Status rc = Decode(*image_tensor, image_tensor);
        if (rc.IsError()) {
          *image_tensor = nullptr;
          std::string err_msg = &quot;Invalid data, failed to decode image: &quot; + file_path;
          return Status(StatusCode::kMDUnexpectedError, __LINE__, __FILE__, err_msg);
        }
    }

    

    return Status::OK();
}

// Read all files in the directory
// @return Status The status code returned
Status Places365Op::WalkAllFiles(){
    RETURN_IF_NOT_OK(LoadCategories(cv::utils::fs::join(root_, K_CATEGORIES_META)));
    RETURN_IF_NOT_OK(LoadFileLists(cv::utils::fs::join(root_, K_FILE_LIST_META.at(usage_))));
    num_rows_ = image_path_label_pairs_.size();
    if (num_rows_ == 0) {
      RETURN_STATUS_UNEXPECTED(
        &quot;Invalid data, no valid data matching the dataset API Places365Dataset. Please check file path or dataset API.&quot;);
    }
    return Status::OK();
}

// Called first when function is called
// @return Status The status code returned
Status Places365Op::LaunchThreadsAndInitOp(){
    if (tree_ == nullptr) {
        RETURN_STATUS_UNEXPECTED(&quot;Pipeline init failed, Execution tree not set.&quot;);
    }
    RETURN_IF_NOT_OK(io_block_queues_.Register(tree_-&gt;AllTasks()));
    RETURN_IF_NOT_OK(wait_for_workers_post_.Register(tree_-&gt;AllTasks()));
    RETURN_IF_NOT_OK(
            tree_-&gt;LaunchWorkers(num_workers_, std::bind(&amp;Places365Op::WorkerEntry, this, std::placeholders::_1), &quot;&quot;, id()));
    TaskManager::FindMe()-&gt;Post();
    RETURN_IF_NOT_OK(this-&gt;WalkAllFiles());
    RETURN_IF_NOT_OK(this-&gt;InitSampler());  // handle shake with sampler



    return Status::OK();
}


Status Places365Op::CountTotalRows(const std::string &amp;dir, const std::string &amp;usage, const bool small, const bool decode, int64_t *count) {
  // the logic of counting the number of samples is copied from ParseMnistData() and uses CheckReader()
  std::shared_ptr&lt;Places365Op&gt; op;
  *count = 0;
  RETURN_IF_NOT_OK(Builder().SetDir(dir).SetUsage(usage).SetSmall(small).SetDecode(decode).Build(&amp;op));

  RETURN_IF_NOT_OK(op-&gt;WalkAllFiles());

  for (size_t i = 0; i &lt; op-&gt;image_path_label_pairs_.size(); ++i) {
    CHECK_FAIL_RETURN_UNEXPECTED(cv::utils::fs::exists(op-&gt;image_path_label_pairs_[i].first),
                                 &quot;Invalid data, num of images is not equal to num of labels.&quot;);
  }
  *count = op-&gt;image_path_label_pairs_.size();

  return Status::OK();
}

Status Places365Op::ComputeColMap() {
  // set the column name map (base class field)
  if (column_name_id_map_.empty()) {
    for (int32_t i = 0; i &lt; data_schema_-&gt;NumColumns(); ++i) {
      column_name_id_map_[data_schema_-&gt;column(i).name()] = i;
    }
  } else {
    MS_LOG(WARNING) &lt;&lt; &quot;Column name map is already set!&quot;;
  }
  return Status::OK();
}


}  // namespace dataset
}  // namespace mindspore

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MIT6.S081 syscall]]></title>
        <id>https://yangyueren.github.io/post/mit6s081-syscall/</id>
        <link href="https://yangyueren.github.io/post/mit6s081-syscall/">
        </link>
        <updated>2021-03-16T06:16:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="syscall的原理">syscall的原理：</h2>
<p>在shell中，当输入某个命令，比如sysinfo，shell fork出一个进程调用sysinfo.c处理sysinfo命令，此时还处于user space；在sysinfo.c的main函数中，会进行系统调用，比如系统调用sysinfo，read，kill等，这些系统调用是通过usys.pl脚本，把sysinfo通过ecall跳转到kernel的部分。</p>
<pre><code>sub entry {
    my $name = shift;
    print &quot;.global $name\n&quot;;
    print &quot;${name}:\n&quot;;
    print &quot; li a7, SYS_${name}\n&quot;;
    print &quot; ecall\n&quot;;
    print &quot; ret\n&quot;;
}
	
entry(&quot;fork&quot;);
entry(&quot;exit&quot;);
entry(&quot;wait&quot;);
entry(&quot;pipe&quot;);
entry(&quot;sysinfo&quot;);
</code></pre>
<p>在kernel的syscall里面查SYS_sysinfo的函数位置，如何查找位置呢，kernel/syscall.c有一个</p>
<pre><code>static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe
}
</code></pre>
<p>可以通过SYSinfo找到对应的sys_sysinfo kernel中的函数，进行操作。</p>
<h2 id="system-call-tracing">System call tracing</h2>
<p>添加一个trace的系统调用</p>
<p>sysproc.c</p>
<pre><code>uint64
sys_trace(void)
{
  int mask;
  if(argint(0, &amp;mask) &lt; 0)
    return -1;
  myproc()-&gt;trace_mask = mask; //进程信息中记录mask
  return 0;
}
</code></pre>
<p>proc.h</p>
<pre><code>
// Per-process state
struct proc {
  struct spinlock lock;

  // p-&gt;lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // these are private to the process, so p-&gt;lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  int trace_mask;               //记录trace mask

};
</code></pre>
<p>syscall.c</p>
<pre><code>
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
...
[SYS_sysinfo] sys_sysinfo,
};


char* syscall_name[23] = {
        &quot;0&quot;,
        &quot;syscall fork&quot;,  
        &quot;syscall exit&quot;,  
        &quot;syscall wait&quot;,  
        &quot;syscall pipe&quot;,  
        &quot;syscall read&quot;,
        &quot;syscall kill&quot;,
        &quot;syscall exec&quot;,
        &quot;syscall fstat&quot;,
        &quot;syscall chdir&quot;,
        &quot;syscall dup&quot;,
        &quot;syscall getpid&quot;,
        &quot;syscall sbrk&quot;,
        &quot;syscall sleep&quot;,
        &quot;syscall uptime&quot;,
        &quot;syscall open&quot;,
        &quot;syscall write&quot;,
        &quot;syscall mknod&quot;,
        &quot;syscall unlink&quot;,
        &quot;syscall link&quot;,
        &quot;syscall mkdir&quot;,
        &quot;syscall close&quot;,
        &quot;syscall trace&quot;,
};
void
syscall(void)
{

  int num;
  struct proc *p = myproc();

  num = p-&gt;trapframe-&gt;a7;
  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {

    p-&gt;trapframe-&gt;a0 = syscalls[num]();
    int trace_mask = p-&gt;trace_mask;
	//判断是否对该syscall显示trace
    if(trace_mask &gt;&gt; num &amp; 0x1){
        printf(&quot;%d: %s -&gt; %d\n&quot;, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);
    }
    
  } else {
    printf(&quot;%d %s: unknown sys call %d\n&quot;,
            p-&gt;pid, p-&gt;name, num);
    p-&gt;trapframe-&gt;a0 = -1;
  }
}



</code></pre>
<p>处理子进程，让mask能够继承<br>
proc.c</p>
<pre><code class="language-c">int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

  // Copy user memory from parent to child.
  if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0){
    freeproc(np);
    release(&amp;np-&gt;lock);
    return -1;
  }
  np-&gt;sz = p-&gt;sz;

  np-&gt;parent = p;

  // copy saved user registers.
  *(np-&gt;trapframe) = *(p-&gt;trapframe);

  // Cause fork to return 0 in the child.
  np-&gt;trapframe-&gt;a0 = 0;

  // increment reference counts on open file descriptors.
  for(i = 0; i &lt; NOFILE; i++)
    if(p-&gt;ofile[i])
      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);
  np-&gt;cwd = idup(p-&gt;cwd);

  safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));

  pid = np-&gt;pid;

  np-&gt;state = RUNNABLE;

  np-&gt;trace_mask = p-&gt;trace_mask; //传递trace_mask

  release(&amp;np-&gt;lock);

  return pid;
}
</code></pre>
<h2 id="sysinfo">Sysinfo</h2>
<p>打印出空闲的内存和未使用的进程<br>
· 如何获取空闲内存：遍历kmem.freelist，每个元素是一个page<br>
· 如何获取未使用的进程：遍历proc.c中的struct proc proc[NPROC];<br>
· 如何将上述信息从内核传递到user space：copyout</p>
<p>sysproc.c</p>
<pre><code class="language-c">
uint64
sys_sysinfo(void)
{
  struct sysinfo info;
  uint64 addr;
  // 获取用户态传入的sysinfo结构体
  if (argaddr(0, &amp;addr) &lt; 0)
    return -1;
  struct proc* p = myproc();
  info.freemem = free_memory();
  info.nproc = proc_unused_num();
  
  //copyout 传入user pagetable，info结构体的user space地址，把kernel中的info copy过去
  if (copyout(p-&gt;pagetable, addr, (char*)&amp;info, sizeof(info)) &lt; 0)
    return -1;
  return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MIT6.S081 util]]></title>
        <id>https://yangyueren.github.io/post/mit6s081-util/</id>
        <link href="https://yangyueren.github.io/post/mit6s081-util/">
        </link>
        <updated>2021-03-16T06:15:29.000Z</updated>
        <content type="html"><![CDATA[<p>第一个lab是熟悉xv6的system calls</p>
<h2 id="sleep">sleep：</h2>
<p>easy难度<br>
在makefile的UPROGS添加$U/_sleep<br>
在user/sleep.c中写以下代码：</p>
<pre><code>#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;

int
main(int argc, char *argv[])
{
  if(argc != 2){
      fprintf(2, &quot;sleep needs an int as param.\n&quot;);
      exit(1);
  }
  int i = atoi(argv[1]);
  sleep(i);
  
  exit(0);
}
</code></pre>
<h2 id="pingpong利用pipe在父子进程间通信利用子进程会继承父进程的打开文件符">pingpong：利用pipe在父子进程间通信（利用子进程会继承父进程的打开文件符）</h2>
<pre><code>#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;

int
main(int argc, char *argv[])
{
  if(argc &gt; 1){
      fprintf(2, &quot;ping-pong doesn't need params\n&quot;);
      exit(1);
  }
  char v = 0;
  
  int parent[2];
  int child[2];
  pipe(parent);
  pipe(child);
  if(fork() == 0){
      //child
      close(child[1]);
      close(parent[0]);
      read(child[0], &amp;v, 1);
      
      if(v==0){
          printf(&quot;%d: received ping\n&quot;, getpid());
      }else{
          exit(1);
      }
      v = 1;
      write(parent[1], &amp;v, 1);
      close(child[0]);
      close(parent[1]);

  }else{
      //parent
      close(child[0]);
      close(parent[1]);
      write(child[1], &amp;v, 1);
      
      read(parent[0], &amp;v, 1);
      if(v==1){
          printf(&quot;%d: received pong\n&quot;, getpid());
      }else{
          exit(1);
      }
      close(parent[0]);
      close(child[1]);

  }
  
  exit(0);
}
</code></pre>
<h2 id="primes利用fork出来的进程树对数据进行过滤">primes：利用fork出来的进程树，对数据进行过滤</h2>
<p>及时关闭用不到的fd</p>
<pre><code>#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;kernel/param.h&quot;
#include &quot;user/user.h&quot;

/*
解题思路：
buffer的作用是保存这轮不能被筛除的数
*/

int
main(int argc, char *argv[])
{

    int fd[2];

    int buffer[36];
    int cnt = 0;
    for (int i = 2; i &lt; 36; i++)
    {
        buffer[cnt++] = i;
    }
    
    while (cnt &gt; 0)
    {   
        pipe(fd);
        if(fork() == 0)
        {
            close(fd[1]);
            int base = 0;
            cnt = -1;
            int v;
            while (read(fd[0], &amp;v, sizeof(v)))
            {
                if(cnt == -1){
                    base = v;
                    cnt = 0;
                }else if(v % base != 0){
                    buffer[cnt++] = v;
                }
            }
            close(fd[0]);
            printf(&quot;prime %d\n&quot;, base);
        }
        else
        {
            close(fd[0]);
            for (int i = 0; i &lt; cnt; i++)
            {
                write(fd[1], &amp;buffer[i], sizeof(buffer[i]));
                
            }
            close(fd[1]);
            wait(0);
            break;  //父进程跳出while循环

        }
    }
    
  
    
      
  
  exit(0);
}

</code></pre>
<h2 id="find利用fstat查看fd的元信息如果是file则拿到文件名如果是directory则读取其中的struct-dirent">find：利用fstat查看fd的元信息，如果是file，则拿到文件名，如果是directory，则读取其中的struct dirent</h2>
<pre><code>#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;
#include &quot;kernel/fs.h&quot;

// extract b from ./a/b
void
extractname(char *path, char *buf)
{
    char *p = path + strlen(path);
    while(*--p != '/'){

    }
    strcpy(buf, p+1);
}

void
find(char *path, char *name)
{
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  if((fd = open(path, 0)) &lt; 0){
      fprintf(2, &quot;find: cannot open %s\n&quot;, path);
        return;
  }
  //fstat是查看该fd的元信息
  if(fstat(fd, &amp;st) &lt; 0){
    fprintf(2, &quot;find: cannot stat %s\n&quot;, path);
    close(fd);
    return;
  }
  switch(st.type){
  case T_FILE:
    extractname(path, buf);
    if(strcmp(buf, name) == 0){
        printf(&quot;%s\n&quot;, path);
    }
    
    break;

  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf){
      printf(&quot;find: path too long\n&quot;);
      break;
    }
    strcpy(buf, path);
    p = buf+strlen(buf);
    *p++ = '/';
    //文件夹也是一个file，从里面会逐个读取文件夹下的内容，每次读一个struct dirent大小
    while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){
      if(de.inum == 0)
        continue;
    
      memmove(p, de.name, DIRSIZ);
      p[DIRSIZ] = 0;
      if(stat(buf, &amp;st) &lt; 0){
        printf(&quot;find: cannot stat %s\n&quot;, buf);
        continue;
      }
    //   printf(&quot;debug %s\n&quot;, buf);
      /* 出现递归
        debug ./.
        debug ././.
        debug ./././.
        debug ././././.
      */
      char *check = buf + strlen(buf);
      while(*check != '/') check--;
      check++;
      if(strcmp(check, &quot;.&quot;) == 0) continue;
      if(strcmp(check, &quot;..&quot;) == 0) continue;

      find(buf, name);
    //   printf(&quot;%s %d %d %d\n&quot;, fmtname(buf), st.type, st.ino, st.size);
    }
    break;
  }
  close(fd);

}


int
main(int argc, char *argv[])
{

  if(argc &lt; 3){
    fprintf(2, &quot;find need at least 3 params\n&quot;);
    exit(1);
  }
  find(argv[1], argv[2]);
  exit(0);
}
</code></pre>
<h2 id="xargs把上一个命令的输出作为下一个命令的输入参数">xargs：把上一个命令的输出作为下一个命令的输入参数</h2>
<pre><code>$ echo hello too | xargs echo bye
bye hello too
</code></pre>
<p>solution:</p>
<pre><code class="language-c">
#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;kernel/param.h&quot;
#include &quot;user/user.h&quot;

int
main(int argc, char *argv[])
{
  char *args[MAXARG];
  int ini_arg_num = 0;
  char buf[256] = {0};
//   printf(&quot;argc %d\n&quot;, argc);
  for(int i=1; i&lt;argc; ++i){
      if(strcmp(argv[i], &quot;-n&quot;) == 0 &amp;&amp; i==1){
          ++i;
      }else{
          args[ini_arg_num++] = argv[i];
        //   printf(&quot;%d %s\n&quot;, ini_arg_num-1, argv[i]);
      }
  }
  /*
  这里有问题 无法解析\n
  $ echo &quot;1\n2&quot; | xargs -n 1 echo line
    &quot;1\n2&quot;
    line &quot;1\n2&quot;

  */
  while(gets( buf, sizeof(buf))){
      if(strlen(buf) &lt; 1) break;
    //   printf(&quot;%d\n%s&quot;, strlen(buf), buf);
      buf[strlen(buf)-1] = 0; //清除gets读入的\n
    //   printf(&quot;%s\n&quot;, buf);
      int arg_num = ini_arg_num;
      char *p = buf;
      while (*p)
      {
          while ((*p == ' ') &amp;&amp; *p) *p++ = 0;
          if(*p) args[arg_num++] = p;
          while ((*p != ' ') &amp;&amp; *p) p++;
      }
      if(arg_num &gt;= MAXARG) fprintf(2, &quot;too many args\n&quot;);
      if(arg_num &lt; 1) fprintf(2, &quot;too few args for xargs\n&quot;);
      args[arg_num] = 0;
      if(fork() == 0){
        //   printf(&quot;%s\n&quot;, args[0]);
        //   printf(&quot;%s %s %s\n&quot;, args[1], args[2], args[3]);
        exec(args[0], args);
        exit(0);
      }else{
          wait(0);
      }
      
  }
  exit(0);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ unique_lock future condition_variable]]></title>
        <id>https://yangyueren.github.io/post/c-unique_lock-future-condition_variable/</id>
        <link href="https://yangyueren.github.io/post/c-unique_lock-future-condition_variable/">
        </link>
        <updated>2021-02-27T14:39:51.000Z</updated>
        <summary type="html"><![CDATA[<p>多线程的一些基础语法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>多线程的一些基础语法。</p>
<!-- more -->
<h2 id="stdunique_lock">std::unique_lock</h2>
<p>使用std::unique_lock 比std::lock_guard更加灵活：std::lock_guard 不能显式的调用 lock 和 unlock，而 std::unique_lock 可以在声明后的任意位 置调用，可以缩小锁的作用范围，提供更高的并发度。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

using namespace std;
int v = 1;
void critical_sectin(int change_v){
    static mutex mtx;
    std::this_thread::sleep_for(std::chrono::milliseconds(change_v));
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    v = change_v;
    std::cout &lt;&lt; v &lt;&lt; std::endl;

    lock.unlock();

    change_v++;

    lock.lock();
    v = change_v;
    std::cout &lt;&lt; v &lt;&lt; std::endl;

}
int main(){
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    std::thread t1(critical_sectin, 590);
    std::thread t2(critical_sectin, 66);
    t1.join();
    t2.join();
    return 0;
}
</code></pre>
<h2 id="stdfuture-对线程的返回结果进行封装">std::future 对线程的返回结果进行封装</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
using namespace std;

int main(){
    std::packaged_task&lt;int(int)&gt; task([](int a) -&gt; int{
        std::cout &lt;&lt; &quot;inside packaged_task &quot; &lt;&lt; a &lt;&lt; std::endl;
        return a;
    });
    std::future&lt;int&gt; result = task.get_future();

    std::thread(std::move(task), 8).detach(); //创建thread，传入package_task的参数
    
    result.wait();
    std::cout &lt;&lt; result.get() &lt;&lt; std::endl;

    
    return 0;
}
</code></pre>
<h2 id="stdcondition_variable">std::condition_variable</h2>
<p>用于同步，解决死锁</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;condition_variable&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
using namespace std;

int main(){
    std::condition_variable cv;
    std::mutex mtx;
    std::queue&lt;int&gt; produced_nums;
    bool notify = false;
    auto producer = [&amp;](){
        for (int i=1; ; i++){
            std::this_thread::sleep_for(std::chrono::milliseconds(900));
            std::unique_lock&lt;mutex&gt; lock(mtx);

            std::cout &lt;&lt; &quot;producing &quot; &lt;&lt; i &lt;&lt; std::endl;

            produced_nums.push(i);
            notify = true;
            cv.notify_all();

        }
    };
    auto consumer = [&amp;](int csid){
        while (true){
            unique_lock&lt;mutex&gt; lock(mtx);

            while (!notify){
                cv.wait(lock);
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(1000));

            std::cout &lt;&lt; csid &lt;&lt; &quot; lock success&quot; &lt;&lt; std::endl;
            if (!produced_nums.empty()){
                auto result = produced_nums.front();
                produced_nums.pop();
                std::cout &lt;&lt; &quot;consumer &quot; &lt;&lt; csid &lt;&lt; &quot; : &quot; &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; produced_nums.size() &lt;&lt; std::endl;
            }
            notify = false;

        }
    };

    thread produce(producer);
    vector&lt;thread&gt; pool;
    for (int i = 0; i &lt; 10; ++i) {
        pool.push_back(thread(consumer, i));
    }

    produce.join();
    for (int i = 0; i &lt; 10; ++i) {
        pool[i].join();
    }

    return 0;
}
</code></pre>
<p>condition_variable需要mutex和condition两个变量，在cv.wait(lock)后，需要检查条件是否满足（因为存在假唤醒）。</p>
<p>consumer中wait被signal之后的过程：</p>
<p>首先要拿到lock，然后cv.wait(lock, <a href=""></a>{return is_ready;});之后，线程开始休眠，被加入一个唤醒队列，同时释放锁。<br>
cv.notify_all()之后，所有在wait的consumer线程被唤醒，然后开始lock，注意，如果mutex此时是被locked的，这些线程也不会再休眠了，会一直尝试加锁，直到加锁成功，进入临界区。</p>
<p>官方样例：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
 
std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;
 
void worker_thread()
{
    // Wait until main() sends data
    std::unique_lock&lt;std::mutex&gt; lk(m);
    cv.wait(lk, []{return ready;});
 
    // after the wait, we own the lock.
    std::cout &lt;&lt; &quot;Worker thread is processing data\n&quot;;
    data += &quot; after processing&quot;;
 
    // Send data back to main()
    processed = true;
    std::cout &lt;&lt; &quot;Worker thread signals data processing completed\n&quot;;
 
    // Manual unlocking is done before notifying, to avoid waking up
    // the waiting thread only to block again (see notify_one for details)
    lk.unlock();
    cv.notify_one();
}
 
int main()
{
    std::thread worker(worker_thread);
 
    data = &quot;Example data&quot;;
    // send data to the worker thread
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        ready = true;
        std::cout &lt;&lt; &quot;main() signals data ready for processing\n&quot;;
    }
    cv.notify_one();
 
    // wait for the worker
    {
        std::unique_lock&lt;std::mutex&gt; lk(m);
        cv.wait(lk, []{return processed;});
    }
    std::cout &lt;&lt; &quot;Back in main(), data = &quot; &lt;&lt; data &lt;&lt; '\n';
 
    worker.join();
}
</code></pre>
<p>output:</p>
<pre><code class="language-markdown">main() signals data ready for processing
Worker thread is processing data
Worker thread signals data processing completed
Back in main(), data = Example data after processing
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ T&&推导T的类型]]></title>
        <id>https://yangyueren.github.io/post/c-you-zhi-yin-yong/</id>
        <link href="https://yangyueren.github.io/post/c-you-zhi-yin-yong/">
        </link>
        <updated>2021-02-27T06:52:36.000Z</updated>
        <summary type="html"><![CDATA[<p>T&amp;&amp;需要推导T的类型时的规则是什么？<br>
为什么最好用 auto&amp;&amp;的形式？<br>
非常量左值引用不能绑定右值<br>
常量左值引用可以绑定右值<br>
右值引用只能绑定右值<br>
为什么需要完美转发？</p>
]]></summary>
        <content type="html"><![CDATA[<p>T&amp;&amp;需要推导T的类型时的规则是什么？<br>
为什么最好用 auto&amp;&amp;的形式？<br>
非常量左值引用不能绑定右值<br>
常量左值引用可以绑定右值<br>
右值引用只能绑定右值<br>
为什么需要完美转发？</p>
<!-- more -->
<p>右值语义的引出</p>
<pre><code>void set(const string &amp; var1, const string &amp; var2){
  m_var1 = var1;  //copy
  m_var2 = var2;  //copy
}
A a1;
string var1(&quot;string1&quot;);
string var2(&quot;string2&quot;);
a1.set(var1, var2); // OK to copy
a1.set(&quot;temporary str1&quot;,&quot;temporary str2&quot;); //也需要copy，浪费

# 引入右值语义
void set(string &amp;&amp; var1, string &amp;&amp; var2){
  //avoid unnecessary copy!
  m_var1 = std::move(var1);  
  m_var2 = std::move(var2);
}
A a1;
//temporary, move! no copy!
a1.set(&quot;temporary str1&quot;,&quot;temporary str2&quot;);

#但是要重载两遍，代码重复，所以引入完美转发

template&lt;typename T1, typename T2&gt;
void set(T1 &amp;&amp; var1, T2 &amp;&amp; var2){
  m_var1 = std::forward&lt;T1&gt;(var1);
  m_var2 = std::forward&lt;T2&gt;(var2);
}

/*

forward 能够转发 [const] T &amp;[T] 的所有情况
const T &amp;
T &amp;
const T &amp;&amp;
T &amp;&amp;

when var1 is an rvalue, std::forward&lt;T1&gt; equals to static_cast&lt;[const] T1 &amp;&amp;&gt;(var1)
when var1 is an lvalue, std::forward&lt;T1&gt; equals to static_cast&lt;[const] T1 &amp;&gt;(var1)

如果外面传来了rvalue临时变量, 它就转发rvalue并且启用move语义.

如果外面传来了lvalue, 它就转发lvalue并且启用复制. 然后它也还能保留const.
*/



</code></pre>
<h1 id="右值引用">右值引用</h1>
<p>auto for loop</p>
<ol>
<li>
<p>当你想要拷贝range的元素时，使用for(auto x : range).</p>
</li>
<li>
<p>当你想要修改range的元素时，使用for(auto &amp;&amp; x : range).</p>
</li>
<li>
<p>当你想要只读range的元素时，使用for(const auto &amp; x : range).</p>
</li>
<li>
<p>其他的auto变种，几乎没有作用。</p>
</li>
</ol>
<p>T&amp;&amp; Doesn’t Always Mean “Rvalue Reference”</p>
<p>by Scott Meyers</p>
<p>https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</p>
<pre><code>Widget&amp;&amp; var1 = someWidget;      // here, “&amp;&amp;” means rvalue reference
 
auto&amp;&amp; var2 = var1;              // here, “&amp;&amp;” does not mean rvalue reference
 
template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param);  // here, “&amp;&amp;” means rvalue reference
 
template&lt;typename T&gt;
void f(T&amp;&amp; param);               // here, “&amp;&amp;”does not mean rvalue reference
</code></pre>
<p>&amp;&amp; is not only type declaration, you will misread a lot of c++11 code.<br>
The essence of the issue is that “&amp;&amp;” in a type declaration sometimes means rvalue reference, but sometimes it means either rvalue reference or lvalue reference.</p>
<p><strong>只有在类型推断（模板和auto）的时候，&amp;&amp;是universe reference，要看传入的值是rvalue还是lvalue：</strong><br>
Universal references can only occur in the form “T&amp;&amp;”!<br>
例如</p>
<pre><code>template &lt;typename T&gt;
void f(T&amp;&amp; param);

f(10) // rvalue

int x = 10;
f(x) // lvalue

template &lt;typename T&gt;
void f(const T&amp;&amp; param)  //rvalue, not universe reference. universe reference只认 T&amp;&amp; 形式
</code></pre>
<pre><code>//error 不能把rvalue绑定到non-const lvalue reference
// 如果把f参数改为const int&amp; a 那就没办法对a进行改变，也有限制
#include &lt;iostream&gt;
using namespace std;

int f(int&amp; a){
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
   cout &lt;&lt; f(3);
   return 0;
}

/*
main.cpp:9:14: error: cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’
    9 |    cout &lt;&lt; f(3);
*/

//一个很好的例子，来说明右值为什么有必要存在

//given the expression E(a, b, ... , c), we want the expression f(a, b, ... , c) to be equivalent. 


//不能处理f(1,2,3)
template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c)
{
    E(a, b, c);
}

# 如果E中要对a b c进行修改，则void E(int&amp;, int&amp;, int&amp;); f(i, j, k); // oops! E cannot modify these
template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(a, b, c);
}

#使用const_cast，但是E修改了const object，与f的函数签名不一致了
template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(const_cast&lt;A&amp;&gt;(a), const_cast&lt;B&amp;&gt;(b), const_cast&lt;C&amp;&gt;(c));
}


#重载跨域解决这个问题  但是2^N的重载个数，太麻烦
template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c);
</code></pre>
<p><br><br></p>
<h2 id="universe-reference-推导规则">universe reference 推导规则</h2>
<pre><code>g1. 形如&quot;T&amp;&amp;&quot;的表达式（必须严格类似这个形式，不可有任何c-v限定符）且T是一个需要推导的东西，那么该表达式的类型可以称为universal reference。
g2. universal reference最终既可以最后推导为左值引用，也可以推导为右值引用。
==&gt;d1. 推论1. 形如&quot;T&amp;&amp;&quot;的表达式，不一定都是右值引用。

g3. 某个变量的类型可以是右值引用，但包含该变量本身可以是左值。（只要能被取址的，就是左值）
特别的，Named variables and parameters of rvalue reference type are lvalues. (You can take their addresses.) [1]
Keep in mind, once inside the function the parameter could be passed as an lvalue to anything. [2]

G4-5 T应该如何被推导？
g4. 当形如&quot;T&amp;&amp;&quot;的universal reference被lvalue初始化时, T被推导为lvalue reference。
g5. 当形如&quot;T&amp;&amp;&quot;的universal reference被rvalue初始化时, T被推导为该rvalue的原生类型。
g6. 当形如&quot;T&amp;&amp;&quot;的universal reference所在模板函数传入的参数为引用类型（无论左值引用还是右值引用）时，实参的引用部分被忽略。
并由于传入的东西是左值（类型是引用，变量本身都为左值），T按g4规则被推导为lvalue reference。

G7-8 universal reference的整体类型最终如何确定？
g7. 当universal reference被lvalue初始化时，universal reference最终是左值引用.
g8. 当universal reference被rvalue初始化时，universal reference最终是右值引用.

g9. 重载与左值引用：
若存在一个函数的重载，其参数是左值引用或右值引用，当传入的参数为左值时，匹配左值引用的重载函数；当传入的参数为右值时，匹配右值引用的重载函数。如果有原生类型的重载函数，则语法会报错“多个重载函数匹配同一个调用”。
</code></pre>
<p>例子</p>
<pre><code>template &lt;typename T&gt;
void f(T&amp;&amp; para) {
	// do something;
}
int x;
int &amp;&amp;a = 10; //a的类型是int&amp;&amp;，右值引用
int &amp;b  = x;  //b的类型是int&amp;，左值引用 
f(10); // 10是右值，para的类型是右值引用，T是10的原生类型也就是int   函数f会实例化为 f(int&amp;&amp; para)
f(x);  // x是左值，para的类型是左值引用，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
f(a);  // g6./g4.  a是右值引用，本身是左值，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
f(b);  // g6./g4. b是左值引用，本身是左值，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
</code></pre>
<p>a是引用，且是一个lvalue</p>
<ul>
<li>a是lvalue  --&gt;  所以T是int&amp;，</li>
<li>a是引用，要引用去掉，只保留本体</li>
</ul>
<p><strong>所以universe reference T&amp;&amp; param：判断T是通过传入的实参是lvalue还是rvalue；如果实参是引用就把引用符号都去掉，且一定是lvalue。</strong></p>
<br>
<p>右值引用</p>
<pre><code>int main() {
    lambda_capture_value();
    int a;
    int &amp;b = a;
    // int &amp;&amp;c = a; //error: rvalue reference to type 'int' cannot bind to lvalue of type 'int'
}
</code></pre>
<p>为什么不允许non-const reference绑定到non-lvaule，因为存在逻辑错误：</p>
<pre><code>void increase(int &amp;v){
    v++;
}
void foo(){
    double s = 1.3;
    increase(s); //报错了：int&amp; 不能引用double类型的参数，所以必须产生一个临时值来保存s的值，从而当increase修改临时值时，s并没有被改变
}
</code></pre>
<p>为什么允许常量引用绑定到非左值，很简单，因为Fortan需要。</p>
<p>T&amp;&amp; + 传入的是右值，模板参数T才会被推导为右引用类型，例如T = int&amp;&amp;</p>
<p>为什么在循环语句中，auto&amp;&amp; 是最安全的方式：因为当auto被推导为不同的左右引用时，与&amp;&amp;的坍塌组合是完美转发（参考forward）</p>
<pre><code>template&lt;typename _Tp&gt;
constexpr _Tp &amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type &amp;__t) noexcept { return static_cast&lt;_Tp &amp;&amp;&gt;(__t); }

template&lt;typename _Tp&gt;
constexpr _Tp &amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type &amp;&amp;__t) noexcept {

    static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot;

                                                         &quot; substituting _Tp is an lvalue reference type&quot;);

    return static_cast&lt;_Tp &amp;&amp;&gt;(__t);
}
</code></pre>
<p>在这份实现中，std::remove_reference 的功能是消除类型中的引用，而 std::is_lvalue_reference 用于检查类型推导是否正确，在 std::forward 的第二个实现中检查了接收到的值确实是一个左值，进 而体现了坍缩规则。<br>
当 std::forward 接受左值时，_Tp 被推导为左值，而所以返回值为左值；而当其接受右值时，_Tp 被推导为右值引用，则基于坍缩规则，返回值便成为了 &amp;&amp; + &amp;&amp; 的右值。可见 std::forward 的原理在 于巧妙的利用了模板类型推导中产生的差异。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MIT Missing Semester in CS Education : Shell Notes]]></title>
        <id>https://yangyueren.github.io/post/mit-missing-semester-in-cs-education-shell-notes/</id>
        <link href="https://yangyueren.github.io/post/mit-missing-semester-in-cs-education-shell-notes/">
        </link>
        <updated>2021-02-27T06:42:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shell-and-useful-tools">shell and useful tools</h1>
<p>找shell命令的历史记录 ctrl-r 快捷键</p>
<p>字符串：<br>
'' ：原义字符串<br>
“” ：转义</p>
<pre><code>foo=bar
echo '$foo'  # $foo
echo &quot;$foo&quot;  # bar
</code></pre>
<p>练习：假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<pre><code>#!/usr/bin/env bash

n=$(( RANDOM % 100 ))

if [[ n -eq 42 ]]; then
	echo &quot;Something went wrong&quot;
	&gt;&amp;2 echo &quot;The error was using magic numbers&quot;
	exit 1
fi

echo &quot;Everything went according to plan&quot;
</code></pre>
<p>solution</p>
<pre><code># !/bin/bash
#$0 - 脚本名
#$1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。
#$@ - 所有参数
#$# - 参数个数
#$? - 前一个命令的返回值; 0 代表正常返回，其他非0返回表示有错误发生
#$$ - 当前脚本的进程识别码
#!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 su    do !!再尝试一次。
file=&quot;failure.sh&quot;

./$file 1&gt;&gt;run.log 2&gt;&gt;error.log
# 1代表stdout 重定向到run.log

while [[ $? -eq 0 ]]; do
     ./$file 1&gt;&gt;run.log 2&gt;&gt;error.log
done

echo &quot;$0 finished&quot;
</code></pre>
<p>sshfd可以将远端服务器的一个文件夹挂载到本地，然后使用本地的编辑器了。</p>
<p>练习：<br>
如果您希望某个进程结束后再开始另外一个进程， 应该如何实现呢？在这个练习中，我们使用 sleep 60 &amp; 作为先执行的程序。一种方法是使用 wait 命令。尝试启动这个休眠命令，然后待其结束后再执行 ls 命令。<br>
但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 wait 只能对子进程起作用。之前我们没有提过的一个特性是，kill 命令成功退出时其状态码为 0 ，其他状态则是非0。kill -0 则不会发送信号，但是会在进程不存在时返回一个不为0的状态码。请编写一个 bash 函数 pidwait ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 sleep 来避免浪费 CPU 性能。</p>
<pre><code>#!/bin/bash
com=&quot;kill -0 $1&quot;
echo $com
$com
while [[ $? -eq 0 ]]; do
	echo &quot;$1 is still running&quot;
	sleep 60
done
echo &quot;$1 doesn't exist&quot;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端 Vue-cli4.x项目执行顺序]]></title>
        <id>https://yangyueren.github.io/post/qian-duan-vue-cli4x-xiang-mu-zhi-xing-shun-xu/</id>
        <link href="https://yangyueren.github.io/post/qian-duan-vue-cli4x-xiang-mu-zhi-xing-shun-xu/">
        </link>
        <updated>2021-02-24T14:42:55.000Z</updated>
        <content type="html"><![CDATA[<p>由于要做一个可视化，选择了vue，但是在使用过程中不清楚vue的启动过程导致写出的代码不够满意，于是在此理顺vue的启动过程。</p>
<p>代码如下：</p>
<pre><code>src
--components
|----HelloWorld.vue
--router
|----index.js
--views
|--Home.vue
--App.vue
main.js
index.html
</code></pre>
<p>启动过程：main.js --&gt; App.vue --&gt; router/index.js --&gt; Home.vue --&gt; HelloWorld.vue</p>
<p>index.html是初始文件，vue会替换掉id=app的dom<br>
index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;title&gt;detection_web_vue&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>main.js是首先执行的文件，是入口函数，创建一个Vue，把App component绑定到#app的dom<br>
main.js</p>
<pre><code>// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  components: { App },
  template: '&lt;App/&gt;'
})

</code></pre>
<p>这里的router-link会被渲染<br>
router-view也会被渲染，进入router/index.js中<br>
App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;img src=&quot;./assets/logo.png&quot;&gt;
    &lt;router-link to='/home'&gt; Home &lt;/router-link&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;

</code></pre>
<p>引入了HelloWorld组件，在Home中使用<br>
router/index.js</p>
<pre><code>import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'
import Home from '@/views/Home'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/home',
      name: 'Home',
      component: Home
    }
  ]
})

</code></pre>
<p>Home.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h2&gt;Essential Links&lt;/h2&gt;
    &lt;HelloWorld/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from '@/components/HelloWorld.vue'
export default {
  name: 'Home',
  components: {
      HelloWorld
  }
}
&lt;/script&gt;

&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;
&lt;style scoped&gt;
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
&lt;/style&gt;

</code></pre>
<p>HelloWorld.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
    &lt;h2&gt;Essential Links&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;https://vuejs.org&quot;
          target=&quot;_blank&quot;
        &gt;
          Core Docs
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;https://forum.vuejs.org&quot;
          target=&quot;_blank&quot;
        &gt;
          Forum
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;https://chat.vuejs.org&quot;
          target=&quot;_blank&quot;
        &gt;
          Community Chat
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;https://twitter.com/vuejs&quot;
          target=&quot;_blank&quot;
        &gt;
          Twitter
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;br&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;http://vuejs-templates.github.io/webpack/&quot;
          target=&quot;_blank&quot;
        &gt;
          Docs for This Template
        &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;Ecosystem&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;http://router.vuejs.org/&quot;
          target=&quot;_blank&quot;
        &gt;
          vue-router
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;http://vuex.vuejs.org/&quot;
          target=&quot;_blank&quot;
        &gt;
          vuex
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;http://vue-loader.vuejs.org/&quot;
          target=&quot;_blank&quot;
        &gt;
          vue-loader
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href=&quot;https://github.com/vuejs/awesome-vue&quot;
          target=&quot;_blank&quot;
        &gt;
          awesome-vue
        &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'HelloWorld',
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}
&lt;/script&gt;

&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;
&lt;style scoped&gt;
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
&lt;/style&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP RIO包用于I/O]]></title>
        <id>https://yangyueren.github.io/post/csapp-rio-bao-yong-yu-io/</id>
        <link href="https://yangyueren.github.io/post/csapp-rio-bao-yong-yu-io/">
        </link>
        <updated>2021-02-07T17:12:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-markdown">RIO

- 解决short count

- 提供方便、健壮、高效的IO

两类函数

- 无缓冲的输入输出

  rio_readn

  rio_writen

​		绝不会返回不足值

- 带缓冲的输入输出

​        rio_readlineb

​            读文本行

​            停止条件

​                读了maxlen个字节

​                遇到了EOF

​                遇到了换行符

​        rio_readnb

​            读字节 不区分文本和二进制文件

​            停止条件

​           	 maxlen : 因为里面用了一个while循环，如果还有left，就继续读，如果buffer已经空了，就调用rio_read填充buffer后再读。

​            	遇到EOF

​        

​        readlineb和readnb可以混用，但不能和readn混用
</code></pre>
<pre><code class="language-c">/*my version of rio*/
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

typedef struct{
    int rio_fd; //file descriptor
    int rio_cnt; //unread bytes
    char rio_buffer[32];
    char *rio_p; //pointer to next unread byte;
} rio_t;

void rio_initb(rio_t *rp, int fd){
    rp-&gt;rio_fd = fd;
    rp-&gt;rio_cnt = 0;
    rp-&gt;rio_p = rp-&gt;rio_buffer;
}

//把buffer里的拷贝进usrbuf
int rio_read(rio_t *rp, char *usrbuf, size_t size){

    while(rp-&gt;rio_cnt &lt;= 0){
        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buffer, sizeof(rp-&gt;rio_buffer));
        if(rp-&gt;rio_cnt &lt; 0){
            if(errno != EINTR){
                return -1;
            }
        }else if(rp-&gt;rio_cnt == 0){
            return 0;
        }else{
            rp-&gt;rio_p = rp-&gt;rio_buffer;
        }
    }
    int cnt = size;
    if(cnt &gt; rp-&gt;rio_cnt){
        cnt = rp-&gt;rio_cnt;
    }
    memcpy(usrbuf, rp-&gt;rio_p, cnt);
    rp-&gt;rio_p += cnt;
    rp-&gt;rio_cnt -= cnt;
    return cnt;
}

int rio_readnb(rio_t *rp, char *des, size_t size){
    int left = size;
    int n;
    char *p = des;
    while(left &gt; 0){
        n = rio_read(rp, p, left);
        if(n &lt; 0){
            return -1; /* errno set by read() */
        }else if(n==0){
            break; /* EOF */
        }else{
            left -= n;
            p += n;
        }
    }
    return (size - left);
}

int rio_readlineb(rio_t *rp, char* des, size_t max_size){
    int left = max_size-1;
    char *p = des;
    int n;
    while(left &gt; 0){
        if(n = rio_read(rp, p, 1) == 1){
            left--;
            if(*p == '\n'){
                p++;
                break;
            }else{
                p++;
            }
            
        }else if(n==0){
            if(p == des) return 0; //no data read, EOF
            else break; // some data read, EOF
        }else{
            return -1;
        }
    }
    *p = 0;
    return p-des;
}

int main()
{
    rio_t rt;
    int fd1 = open(&quot;README2&quot;, O_RDONLY);
    rio_initb(&amp;rt, fd1);

    
    char buf[64];
    int size = 64;
    rio_readlineb(&amp;rt, buf, size);
    printf(&quot;%s&quot;, buf);

}
</code></pre>
<pre><code class="language-c">
/****************************************
 * The Rio package - Robust I/O functions
 ****************************************/

/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft &gt; 0)
    {
        if ((nread = read(fd, bufp, nleft)) &lt; 0)
        {
            if (errno == EINTR) /* Interrupted by sig handler return */
                nread = 0;      /* and call read() again */
            else
                return -1; /* errno set by read() */
        }
        else if (nread == 0)
            break; /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft); /* Return &gt;= 0 */
}
/* $end rio_readn */

/*
 * rio_writen - Robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft &gt; 0)
    {
        if ((nwritten = write(fd, bufp, nleft)) &lt;= 0)
        {
            if (errno == EINTR) /* Interrupted by sig handler return */
                nwritten = 0;   /* and call write() again */
            else
                return -1; /* errno set by write() */
        }
        nleft -= nwritten;
        bufp += nwritten;
    }
    return n;
}
/* $end rio_writen */

/* 
 * rio_read - This is a wrapper for the Unix read() function that
 *    transfers min(n, rio_cnt) bytes from an internal buffer to a user
 *    buffer, where n is the number of bytes requested by the user and
 *    rio_cnt is the number of unread bytes in the internal buffer. On
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp-&gt;rio_cnt &lt;= 0)
    { /* Refill if buf is empty */
        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf,
                           sizeof(rp-&gt;rio_buf));
        if (rp-&gt;rio_cnt &lt; 0)
        {
            if (errno != EINTR) /* Interrupted by sig handler return */
                return -1;
        }
        else if (rp-&gt;rio_cnt == 0) /* EOF */
            return 0;
        else
            rp-&gt;rio_bufptr = rp-&gt;rio_buf; /* Reset buffer ptr */
    }

    /* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */
    cnt = n;
    if (rp-&gt;rio_cnt &lt; n)
        cnt = rp-&gt;rio_cnt;
    memcpy(usrbuf, rp-&gt;rio_bufptr, cnt);
    rp-&gt;rio_bufptr += cnt;
    rp-&gt;rio_cnt -= cnt;
    return cnt;
}
/* $end rio_read */

/*
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd)
{
    rp-&gt;rio_fd = fd;
    rp-&gt;rio_cnt = 0;
    rp-&gt;rio_bufptr = rp-&gt;rio_buf;
}
/* $end rio_readinitb */

/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft &gt; 0)
    {
        if ((nread = rio_read(rp, bufp, nleft)) &lt; 0)
            return -1; /* errno set by read() */
        else if (nread == 0)
            break; /* EOF */
        nleft -= nread;
        bufp += nread;
    }
    return (n - nleft); /* return &gt;= 0 */
}
/* $end rio_readnb */

/* 
 * rio_readlineb - Robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n &lt; maxlen; n++)
    {
        if ((rc = rio_read(rp, &amp;c, 1)) == 1)
        {
            *bufp++ = c;
            if (c == '\n')
            {
                n++;
                break;
            }
        }
        else if (rc == 0)
        {
            if (n == 1)
                return 0; /* EOF, no data read */
            else
                break; /* EOF, some data was read */
        }
        else
            return -1; /* Error */
    }
    *bufp = 0;
    return n - 1;
}
/* $end rio_readlineb */
</code></pre>
]]></content>
    </entry>
</feed>