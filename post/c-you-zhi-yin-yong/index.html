<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[一只木头人]的个人博客">
<meta name="author" content="kveln">
<title>C++ T&amp;&amp;推导T的类型 | 一只木头人</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="C++ T&amp;&amp;推导T的类型 | 一只木头人 » Feed"
  href="https://yangyueren.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://yangyueren.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="C++ T&amp;&amp;推导T的类型" />
  <meta property="og:url" content="https://yangyueren.github.io/post/c-you-zhi-yin-yong/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="一只木头人" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://yangyueren.github.io">一只木头人</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1617098662543"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://yangyueren.github.io">一只木头人</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1617098662543"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://yangyueren.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://yangyueren.github.io/tag/1YnKKTmmU/" class="tag">C++</a>
                
              </span>
              <h1>C++ T&amp;&amp;推导T的类型</h1>
              <span class="meta">
                Posted on
                2021-02-27，12 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <p>T&amp;&amp;需要推导T的类型时的规则是什么？<br>
为什么最好用 auto&amp;&amp;的形式？<br>
非常量左值引用不能绑定右值<br>
常量左值引用可以绑定右值<br>
右值引用只能绑定右值<br>
为什么需要完美转发？</p>
<!-- more -->
<p>右值语义的引出</p>
<pre><code>void set(const string &amp; var1, const string &amp; var2){
  m_var1 = var1;  //copy
  m_var2 = var2;  //copy
}
A a1;
string var1(&quot;string1&quot;);
string var2(&quot;string2&quot;);
a1.set(var1, var2); // OK to copy
a1.set(&quot;temporary str1&quot;,&quot;temporary str2&quot;); //也需要copy，浪费

# 引入右值语义
void set(string &amp;&amp; var1, string &amp;&amp; var2){
  //avoid unnecessary copy!
  m_var1 = std::move(var1);  
  m_var2 = std::move(var2);
}
A a1;
//temporary, move! no copy!
a1.set(&quot;temporary str1&quot;,&quot;temporary str2&quot;);

#但是要重载两遍，代码重复，所以引入完美转发

template&lt;typename T1, typename T2&gt;
void set(T1 &amp;&amp; var1, T2 &amp;&amp; var2){
  m_var1 = std::forward&lt;T1&gt;(var1);
  m_var2 = std::forward&lt;T2&gt;(var2);
}

/*

forward 能够转发 [const] T &amp;[T] 的所有情况
const T &amp;
T &amp;
const T &amp;&amp;
T &amp;&amp;

when var1 is an rvalue, std::forward&lt;T1&gt; equals to static_cast&lt;[const] T1 &amp;&amp;&gt;(var1)
when var1 is an lvalue, std::forward&lt;T1&gt; equals to static_cast&lt;[const] T1 &amp;&gt;(var1)

如果外面传来了rvalue临时变量, 它就转发rvalue并且启用move语义.

如果外面传来了lvalue, 它就转发lvalue并且启用复制. 然后它也还能保留const.
*/



</code></pre>
<h1 id="右值引用">右值引用</h1>
<p>auto for loop</p>
<ol>
<li>
<p>当你想要拷贝range的元素时，使用for(auto x : range).</p>
</li>
<li>
<p>当你想要修改range的元素时，使用for(auto &amp;&amp; x : range).</p>
</li>
<li>
<p>当你想要只读range的元素时，使用for(const auto &amp; x : range).</p>
</li>
<li>
<p>其他的auto变种，几乎没有作用。</p>
</li>
</ol>
<p>T&amp;&amp; Doesn’t Always Mean “Rvalue Reference”</p>
<p>by Scott Meyers</p>
<p>https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</p>
<pre><code>Widget&amp;&amp; var1 = someWidget;      // here, “&amp;&amp;” means rvalue reference
 
auto&amp;&amp; var2 = var1;              // here, “&amp;&amp;” does not mean rvalue reference
 
template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param);  // here, “&amp;&amp;” means rvalue reference
 
template&lt;typename T&gt;
void f(T&amp;&amp; param);               // here, “&amp;&amp;”does not mean rvalue reference
</code></pre>
<p>&amp;&amp; is not only type declaration, you will misread a lot of c++11 code.<br>
The essence of the issue is that “&amp;&amp;” in a type declaration sometimes means rvalue reference, but sometimes it means either rvalue reference or lvalue reference.</p>
<p><strong>只有在类型推断（模板和auto）的时候，&amp;&amp;是universe reference，要看传入的值是rvalue还是lvalue：</strong><br>
Universal references can only occur in the form “T&amp;&amp;”!<br>
例如</p>
<pre><code>template &lt;typename T&gt;
void f(T&amp;&amp; param);

f(10) // rvalue

int x = 10;
f(x) // lvalue

template &lt;typename T&gt;
void f(const T&amp;&amp; param)  //rvalue, not universe reference. universe reference只认 T&amp;&amp; 形式
</code></pre>
<pre><code>//error 不能把rvalue绑定到non-const lvalue reference
// 如果把f参数改为const int&amp; a 那就没办法对a进行改变，也有限制
#include &lt;iostream&gt;
using namespace std;

int f(int&amp; a){
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
   cout &lt;&lt; f(3);
   return 0;
}

/*
main.cpp:9:14: error: cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’
    9 |    cout &lt;&lt; f(3);
*/

//一个很好的例子，来说明右值为什么有必要存在

//given the expression E(a, b, ... , c), we want the expression f(a, b, ... , c) to be equivalent. 


//不能处理f(1,2,3)
template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c)
{
    E(a, b, c);
}

# 如果E中要对a b c进行修改，则void E(int&amp;, int&amp;, int&amp;); f(i, j, k); // oops! E cannot modify these
template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(a, b, c);
}

#使用const_cast，但是E修改了const object，与f的函数签名不一致了
template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c)
{
    E(const_cast&lt;A&amp;&gt;(a), const_cast&lt;B&amp;&gt;(b), const_cast&lt;C&amp;&gt;(c));
}


#重载跨域解决这个问题  但是2^N的重载个数，太麻烦
template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(A&amp; a, const B&amp; b, const C&amp; c);

template &lt;typename A, typename B, typename C&gt;
void f(const A&amp; a, const B&amp; b, const C&amp; c);
</code></pre>
<p><br><br></p>
<h2 id="universe-reference-推导规则">universe reference 推导规则</h2>
<pre><code>g1. 形如&quot;T&amp;&amp;&quot;的表达式（必须严格类似这个形式，不可有任何c-v限定符）且T是一个需要推导的东西，那么该表达式的类型可以称为universal reference。
g2. universal reference最终既可以最后推导为左值引用，也可以推导为右值引用。
==&gt;d1. 推论1. 形如&quot;T&amp;&amp;&quot;的表达式，不一定都是右值引用。

g3. 某个变量的类型可以是右值引用，但包含该变量本身可以是左值。（只要能被取址的，就是左值）
特别的，Named variables and parameters of rvalue reference type are lvalues. (You can take their addresses.) [1]
Keep in mind, once inside the function the parameter could be passed as an lvalue to anything. [2]

G4-5 T应该如何被推导？
g4. 当形如&quot;T&amp;&amp;&quot;的universal reference被lvalue初始化时, T被推导为lvalue reference。
g5. 当形如&quot;T&amp;&amp;&quot;的universal reference被rvalue初始化时, T被推导为该rvalue的原生类型。
g6. 当形如&quot;T&amp;&amp;&quot;的universal reference所在模板函数传入的参数为引用类型（无论左值引用还是右值引用）时，实参的引用部分被忽略。
并由于传入的东西是左值（类型是引用，变量本身都为左值），T按g4规则被推导为lvalue reference。

G7-8 universal reference的整体类型最终如何确定？
g7. 当universal reference被lvalue初始化时，universal reference最终是左值引用.
g8. 当universal reference被rvalue初始化时，universal reference最终是右值引用.

g9. 重载与左值引用：
若存在一个函数的重载，其参数是左值引用或右值引用，当传入的参数为左值时，匹配左值引用的重载函数；当传入的参数为右值时，匹配右值引用的重载函数。如果有原生类型的重载函数，则语法会报错“多个重载函数匹配同一个调用”。
</code></pre>
<p>例子</p>
<pre><code>template &lt;typename T&gt;
void f(T&amp;&amp; para) {
	// do something;
}
int x;
int &amp;&amp;a = 10; //a的类型是int&amp;&amp;，右值引用
int &amp;b  = x;  //b的类型是int&amp;，左值引用 
f(10); // 10是右值，para的类型是右值引用，T是10的原生类型也就是int   函数f会实例化为 f(int&amp;&amp; para)
f(x);  // x是左值，para的类型是左值引用，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
f(a);  // g6./g4.  a是右值引用，本身是左值，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
f(b);  // g6./g4. b是左值引用，本身是左值，T是左值引用，函数f会实例化为 f(int&amp; &amp;&amp; para)
</code></pre>
<p>a是引用，且是一个lvalue</p>
<ul>
<li>a是lvalue  --&gt;  所以T是int&amp;，</li>
<li>a是引用，要引用去掉，只保留本体</li>
</ul>
<p><strong>所以universe reference T&amp;&amp; param：判断T是通过传入的实参是lvalue还是rvalue；如果实参是引用就把引用符号都去掉，且一定是lvalue。</strong></p>
<br>
<p>右值引用</p>
<pre><code>int main() {
    lambda_capture_value();
    int a;
    int &amp;b = a;
    // int &amp;&amp;c = a; //error: rvalue reference to type 'int' cannot bind to lvalue of type 'int'
}
</code></pre>
<p>为什么不允许non-const reference绑定到non-lvaule，因为存在逻辑错误：</p>
<pre><code>void increase(int &amp;v){
    v++;
}
void foo(){
    double s = 1.3;
    increase(s); //报错了：int&amp; 不能引用double类型的参数，所以必须产生一个临时值来保存s的值，从而当increase修改临时值时，s并没有被改变
}
</code></pre>
<p>为什么允许常量引用绑定到非左值，很简单，因为Fortan需要。</p>
<p>T&amp;&amp; + 传入的是右值，模板参数T才会被推导为右引用类型，例如T = int&amp;&amp;</p>
<p>为什么在循环语句中，auto&amp;&amp; 是最安全的方式：因为当auto被推导为不同的左右引用时，与&amp;&amp;的坍塌组合是完美转发（参考forward）</p>
<pre><code>template&lt;typename _Tp&gt;
constexpr _Tp &amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type &amp;__t) noexcept { return static_cast&lt;_Tp &amp;&amp;&gt;(__t); }

template&lt;typename _Tp&gt;
constexpr _Tp &amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type &amp;&amp;__t) noexcept {

    static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot;

                                                         &quot; substituting _Tp is an lvalue reference type&quot;);

    return static_cast&lt;_Tp &amp;&amp;&gt;(__t);
}
</code></pre>
<p>在这份实现中，std::remove_reference 的功能是消除类型中的引用，而 std::is_lvalue_reference 用于检查类型推导是否正确，在 std::forward 的第二个实现中检查了接收到的值确实是一个左值，进 而体现了坍缩规则。<br>
当 std::forward 接受左值时，_Tp 被推导为左值，而所以返回值为左值；而当其接受右值时，_Tp 被推导为右值引用，则基于坍缩规则，返回值便成为了 &amp;&amp; + &amp;&amp; 的右值。可见 std::forward 的原理在 于巧妙的利用了模板类型推导中产生的差异。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</a>
<ul>
<li><a href="#universe-reference-%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99">universe reference 推导规则</a></li>
</ul>
</li>
</ul>
</div>
          
          <hr />
          <p class="next-post">下一篇：
            <a href="https://yangyueren.github.io/post/mit-missing-semester-in-cs-education-shell-notes/">
              <span class="post-title">
                MIT Missing Semester in CS Education : Shell Notes&rarr;
              </span>
            </a>
          </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/yangyueren" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://yangyueren.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>一只木头人</span><br>Powered by Gridea</p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://yangyueren.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://yangyueren.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://yangyueren.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://yangyueren.github.io/";
        addScript("https://yangyueren.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://yangyueren.github.io/media/scripts/tocScript.js"></script>
</body>

</html>