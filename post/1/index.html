<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[木头人]的个人博客">
<meta name="author" content="kveln">
<title>Chaggie Search Engine | 木头人</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link
  href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800'
  rel='stylesheet' type='text/css'>
<link rel="alternate" type="application/rss+xml" title="Chaggie Search Engine | 木头人 » Feed"
  href="https://yangyueren.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://yangyueren.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="Chaggie Search Engine" />
  <meta property="og:url" content="https://yangyueren.github.io/post/1/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="木头人" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://yangyueren.github.io">木头人</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1614410884924"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://yangyueren.github.io">木头人</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1614410884924"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://yangyueren.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://yangyueren.github.io/tag/-X48vvFK4/" class="tag">Java</a>
                
                <a href="https://yangyueren.github.io/tag/G8d84sNBoy/" class="tag">Sprint boot</a>
                
                <a href="https://yangyueren.github.io/tag/6keKeZ9_mG/" class="tag">Elasticsearch</a>
                
              </span>
              <h1>Chaggie Search Engine</h1>
              <span class="meta">
                Posted on
                2019-07-20，19 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <p>这是大三暑假完成的一个基于Elasticsearch的搜索引擎，后端及ES部分由我用Spring boot完成，前端和爬虫由队友完成。</p>
<!-- more -->
<h2 id="基于elasticsearch集群的数据查询优化">基于Elasticsearch集群的数据查询优化</h2>
<p>Elasticsearch是一个基于Lucene的分布式全文搜索引擎，能够横向扩展数以百计的服务器，存储PB级的数据，而且对每个字段都可以建立索引并且检索，并且可以在极短的时间内存储、搜索和分析大量的数据，程序员最爱的网站Github的搜索就是基于ES构建的，GitHub大约有30TB的索引文件数据，由此可见Elasticsearch（下文简称ES）强大的搜索功能。</p>
<p>在此次的深度搜索引擎项目之中，虽然Elasticsearch也可以在一个节点上使用，该节点可以同时担任master node和data node，但是为了发挥Elasticsearch的分布式搜索的优势，在我们的深度搜索引擎中我们使用了三台服务器提供Elasticsearch的服务。下文将详细介绍从集群部署到优化查询的一些要点。</p>
<h3 id="一-elasticsearch的集群部署">一、Elasticsearch的集群部署</h3>
<h4 id="1-es概念简介">1. ES概念简介</h4>
<p>Elasticsearch中有几个比较重要的概念，集群是指连接在一起的若干台服务器，不同的服务器承担不同的角色，一起提供服务。集群中有主节点、数据节点和客户端节点等。主节点负责管理整个集群，当群集的拓扑结构改变时把索引分片分派到相应的节点上，主节点是从可以担任主节点的节点中选举出来的。数据节点只负责存储数据，客户端节点在选举主节点过程中起作用。ES的分片是把索引信息分散到多个节点上，相当于一桶水用多个杯子装。副本是指索引信息的拷贝。</p>
<p>在进行ES的配置时，首先要考虑节点数和分片数。通过实验，多节点的ES集群中的节点数至少为3，分片数为一倍的节点数量到两倍的节点数量。</p>
<p>节点数和分片数相等时，每个节点负责一个分片的检索，ES集群的性能可以达到最优。对于一个3节点集群，为每个节点分配一个分片，总共3个分片。但是由于ES的不可变性的限制，系统无法对分片进行重新拆分分配，除非重新索引这个文件集合。但是我在三个节点的集群中再加入一个节点，这时候分片数量小于了节点数，在搜索上效率会降低，所以为了支持水平扩展，可以为集群分配比节点数更多的分片数，也就是说每个节点有多个分片。但是每个节点有多个分片时，需要考虑性能的问题，每个节点最好不要超过两个分片，</p>
<p>我采用了官方给默认配置中分片数目为5，这样既可以拓展到5个节点，也可以保证性能。</p>
<p>我的集群的其余配置如下图：</p>
<pre><code class="language-json">#节点集群名称和节点类型
cluster.name: yang-es-clusters
node.name: node-3
node.master: true
node.data: true
#同个集群其他节点的信息，ES通过广播的方式寻找同一集群的其他节点
discovery.zen.ping.unicast.hosts: [ &quot;0.0.0.0&quot;, &quot;106.14.191.xxx&quot;, &quot;120.79.191.xxx&quot;]
#选举主节点时需要由至少2个节点参与投票
discovery.zen.minimum_master_nodes: 2
gateway.recover_after_nodes: 1
#配置本节点的ip，默认开发9300端口用于节点间TCP通信
network.host: 0.0.0.0
network.publish_host: 106.14.227.30
network.bind_host: 0.0.0.0

</code></pre>
<h4 id="2-elsaticsearch集群至少需要有三个节点">2. Elsaticsearch集群至少需要有三个节点</h4>
<p>上文写到我们组搭建的ES集群使用了三台服务器，这也是搭建ES集群所需的最少节点数，是因为需要防止ES集群发生脑裂。ES中维护索引状态最重要的节点是主节点，主节点是被投票选举出来的。</p>
<h5 id="三个和尚投票">三个和尚投票</h5>
<p>当主节点出现问题，从节点不能与主节点通信时，从节点会发起选举任命新的主节点，同时新的主节点会接管旧的主节点的所有工作，如果旧的主节点重新恢复并加入到集群中，新的主节点会将原来旧的主节点降级为从节点，这样就不会有冲突发生。所有这个过程都由ES自己处理，使用者无需任何参与。</p>
<h5 id="两个和尚投票">两个和尚投票</h5>
<p>但是，当只有两个节点的时候，一主（master）一从（slave），如果主从直接的通信出现问题时，从节点slave会自我提升为master，但是当恢复通信时，我们就会同时有两个master。因为此时，对于原来的主节点角度考虑，它认为是原来的从节点出现问题，现在仍然需要作为slave重新加入。这样，两个节点的时候，我们就出现了集群不知道将哪个节点选举为主节点的情况，也就是我们通常说的“分脑”。</p>
<p>为了防止这种情况的发生，第三个节点的出现会打破平衡，解决冲突问题。</p>
<h5 id="三个和尚仍然存在问题">三个和尚仍然存在问题</h5>
<p>分脑的问题同样会出现在具有三或三个以上节点的集群中，为了降低发生的概率，ElasticSearch提供了一个配置 <code>discovery.zen.minimum_master_nodes</code>它规定了在选举新的master时，一个集群下最少需要的节点数。例如，一个3节点集群，这个数字为2，2个节点可以防止单个节点在脱离集群时，将其自己选举成master，相反，它会等待直到重新加入到集群中。这个数值可以通过一个公式确定：</p>
<p>这里的配置是指当主节点宕掉掉时候至少同时需要几个节点才重新进行投票选举新的主节点，官方建议将此数目配置为<code>N / 2 + 1</code>，可以有效的防止脑裂。</p>
<pre><code class="language-json">discovery.zen.minimum_master_nodes: 2
</code></pre>
<p>从图中分析可以得知，如果只有两个节点，当这两个节点通讯故障的时候，会各自选举自己为主节点，而当通讯恢复正常时候会发生冲突，这与区块链的思想不谋而合，只有控制了51%以上的节点，才可以掌控整个集群。</p>
<p>我在配置ES的时候，主节点所在的服务器由于网络问题，经常会发生断网的现象，此时集群的状态会由绿色（正常）转变为红色（预警）状态，而当非主节点宕机的时候，集群状态会变为黄色（所有的主分片可用，但是副本分片不可用）。这个问题的解决方案只有一种，设置容易宕机的节点为数据节点，禁止其被选举为主节点。</p>
<h3 id="二-elasticsearch的查询参数优化">二、Elasticsearch的查询参数优化</h3>
<h4 id="1-lucene的打分模型">1. Lucene的打分模型</h4>
<figure data-type="image" tabindex="1"><img src="http://www.biaodianfu.com/wp-content/uploads/2016/09/lucene-tf-idf.png" alt="lucene-tf-idf" loading="lazy"></figure>
<p>由于ES是基于Lucene，所以ES也是使用的打分机制。通过上面的公式，一篇文档的分数实际上是由查询语句q和文档d作为变量的一个函数值。打分公式中有两部分不直接依赖于查询词，它们是coord和queryNorm。公式的值是这样计算的，coord和queryNorm两大部分直接乘以查询语句中每个查询词计算值的总和。另一方面，这个总和也是由每个查询词的词频(tf)，逆文档频率(idf)，查询词的权重，还有norm，也就是前面说的length norm相乘而得的结果。</p>
<p>从中可以得出以下几条规则：</p>
<ul>
<li>匹配到的关键词越稀有，文档的得分就越高。</li>
<li>文档的域越小(包含比较少的Term)，文档的得分就越高。</li>
<li>设置的权重(索引和搜索时设置的都可以)越大，文档得分越高。</li>
</ul>
<p>随着Lucene的发展，打分模型也引入了新的相似度模型，并且可以在ES中指定，现在比较流行的是Okapi BM25，Divergence from randomness和Information based。</p>
<p>BM25是基于概率模型的相似度模型，适合处理短文本，关键词的重复次数对整个文档得分影响比较大。DFR和IB比较类似，基于同名概率模型，适用于自然语言类的文本。我们的搜索引擎要搜索的字段比较少，内容也是以短文本为主，并且倾向于能够对名字和标签进行准确匹配，如果关键词在内容中多次重复，明显词条是用户所查询的结果，所以BM25更加适合我们的搜索引擎。</p>
<h4 id="2-分词器的选择">2. 分词器的选择</h4>
<p>ES是基于词的搜索引擎，其能够快速的通过搜索词检索出对应的文章归功于倒排索引，使用不同的分词器对于检索效果也有重大影响。</p>
<p>ES的默认分词器对英文句子的切割效果比较好，但用于中文句子的分割时，只会将句子分割成孤立的一个个的字，所以需要指定建立索引时的分词器和搜索分词器。我们使用的是IKAnalyzer，是目前比较流行的中文分词器之一,设置比较简单,稳定。</p>
<p>在Sprint Boot中建立索引时候，对ES的支持度不如直接在ES里面自己建立索引可操作性高，以下是我建立索引的代码。</p>
<pre><code class="language-json">curl -XPOST http://106.14.227.30:9200/chageng/EntryDb/_mapping -H 'Content-Type:application/json' -d' { &quot;EntryDb&quot;: { &quot;properties&quot;: {
    &quot;content&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,
        &quot;fields&quot;: {
            &quot;keyword&quot;: {
                &quot;type&quot;: &quot;text&quot;,
                &quot;analyzer&quot;: &quot;ik_max_word&quot;,
                &quot;search_analyzer&quot;: &quot;ik_smart&quot;
            }
        }
    },
    &quot;imageList&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;fields&quot;: {
            &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
            }
        }
    },
    &quot;like&quot;: {
        &quot;type&quot;: &quot;long&quot;
    },
    &quot;name&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,
        &quot;fields&quot;: {
            &quot;keyword&quot;: {
                &quot;type&quot;: &quot;text&quot;,
                &quot;analyzer&quot;: &quot;ik_max_word&quot;,
                &quot;search_analyzer&quot;: &quot;ik_smart&quot;
            }
        }
    }
}'
</code></pre>
<h4 id="3-查询语句的优化">3. 查询语句的优化</h4>
<h5 id="31-term-match与multi_match">3.1 term、match与multi_match</h5>
<p>ES中的term是代表完全匹配，也就是精确查询，搜索前不会再对搜索词进行分词，所以我们的搜索词必须是文档分词集合中的一个。以下代码将会在name中精确匹配为“小鸡快跑”的词条。</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
  &quot;query&quot;:{
    &quot;term&quot;:{
        &quot;name&quot;:&quot;小鸡快跑&quot;
    }
  }
}'
</code></pre>
<p>ES的match搜索会先对搜索词进行分词，对于最基本的match搜索来说，只要搜索词的分词集合中的一个或多个存在于文档中即可，例如，当我们搜索<code>小鸡快跑</code>，搜索词会先分词为<code>小鸡</code>和<code>快跑</code>,只要文档中包含<code>小鸡</code>和<code>快跑</code>任意一个词，都会被搜索到。</p>
<p>如果文档1中有<code>小鸡</code>，文档2中有<code>快跑</code>，那么这两个文档都会被检索到，而如果文档3中有<code>小鸡</code>和<code>快跑</code>两个词，文档3也将被返回，并且文档3将被排在首位。所有被返回的文档将依靠_score的分数进行排序，得分的算法参考上文。</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
    &quot;query&quot;: {
        &quot;match&quot;: {
            &quot;content&quot;: &quot;小鸡快跑&quot;
        }
    }
}'
</code></pre>
<p>ES的multi_match是对多个字段进行匹配，其中一个字段包含分词，该文档即可被搜索到并且返回。在实际使用中用的比较多。</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
&quot;query&quot;: {
&quot;bool&quot;: {
    &quot;must&quot;: {
        &quot;match&quot;: {
            &quot;tagList&quot;: &quot;社交&quot;
        }
    },
    &quot;should&quot;: {
        &quot;multi_match&quot;: {
            &quot;query&quot;: &quot;吓得我瓜子都掉了&quot;,
            &quot;type&quot;: &quot;best_fields&quot;,
            &quot;fields&quot;: [
                &quot;name^2&quot;,
                &quot;content&quot;
            ],
	          &quot;fuzziness&quot;: &quot;AUTO&quot;,
            &quot;tie_breaker&quot;: 0.4,
            &quot;minimum_should_match&quot;: &quot;30%&quot;
        }
    }
}
}
}
'
</code></pre>
<h5 id="32-组合过滤器bool">3.2 组合过滤器bool</h5>
<p><code>bool</code> 过滤器通过 <code>and</code> 、 <code>or</code> 和 <code>not</code> 逻辑组合将多个过滤器进行组合。<code>bool</code> 查询可以接受 <code>must</code> 、 <code>must_not</code> 和 <code>should</code> 参数下的多个查询语句，对查询结果进行筛选，分别对应<code>AND NOT OR</code>。<code>bool</code> 查询会为每个文档计算相关度评分 <code>_score</code> ， 再将所有匹配的 <code>must</code> 和 <code>should</code> 语句的分数 <code>_score</code> 求和，最后除以 <code>must</code> 和 <code>should</code> 语句的总数。</p>
<p><code>must_not</code> 语句不会影响评分； 它的作用只是将不相关的文档排除。</p>
<p><code>should</code>过滤的数量是由<code>minimum_should_match</code>参数来进行控制，该参数可以是百分比，也可以是一个数字，我在多次实验后发现40%的效果最好。</p>
<p>以下是bool的基本用法。</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
&quot;query&quot;: {
&quot;bool&quot;: {
    &quot;must&quot;: {
        &quot;match&quot;: {
            &quot;tagList&quot;: &quot;游戏&quot;
        }
    },
    &quot;should&quot;: {
        &quot;multi_match&quot;: {
            &quot;query&quot;: &quot;秦王&quot;,
            &quot;type&quot;: &quot;best_fields&quot;,
            &quot;fields&quot;: [
                &quot;name^5&quot;,
              	&quot;tagList^2&quot;,
                &quot;content^1&quot;
            ],
            &quot;tie_breaker&quot;: 0.4,
            &quot;minimum_should_match&quot;: &quot;40%&quot;
        }
    },
    &quot;filter&quot;: {
        &quot;range&quot;: {
            &quot;time&quot;: {
                &quot;gte&quot;: &quot;2012-09-09&quot;,
                &quot;lt&quot;: &quot;2019-09-09&quot;
            }
        }
    }
}
}
}'
</code></pre>
<h5 id="33-boost权重控制">3.3 boost权重控制</h5>
<p>在多字段匹配中，我在name tagList 和 content字段中对内容进行查询，但是想让name字段拥有有更高的权重，可以通过指定 <code>boost</code> 来控制任何查询语句的相对的权重， <code>boost</code> 的默认值为 <code>1</code> ，大于 <code>1</code> 会提升一个语句的相对权重。基本使用见上条ES语句。</p>
<p>基于 TF/IDF 的评分模型中，如果使用了<code>boost</code>改变权重，新的评分 <code>_score</code> 会在应用权重提升之后进行归一化处理 ，并不是线性的变化。</p>
<h5 id="34-模糊匹配">3.4 模糊匹配</h5>
<p>模糊查询的工作原理是给定原始词项及构造一个编辑自动机— 像表示所有原始字符串指定编辑距离的字符串的一个大图表。然后模糊查询使用这个自动机依次高效遍历词典中的所有词项以确定是否匹配。 一旦收集了词典中存在的所有匹配项，就可以计算匹配文档列表。在搜索巨大文档时候，模糊匹配的效率很低，故可以用以下两个参数限制对性能的影响，prefix_length为不能被 “模糊化” 的初始字符数，建议设置为了3，max_expansions限制产生的模糊选项的总数量。</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
    &quot;query&quot;: {
        &quot;multi_match&quot;: {
            &quot;query&quot;: &quot;吓得我瓜子都掉了&quot;,
            &quot;type&quot;: &quot;best_fields&quot;,
            &quot;fields&quot;: [
                &quot;name^2&quot;,
                &quot;content&quot;
            ],
            &quot;fuzziness&quot;: &quot;AUTO&quot;,
            &quot;tie_breaker&quot;: 0.4,
            &quot;minimum_should_match&quot;: &quot;40%&quot;
        }
    }
}'
</code></pre>
<h5 id="35-随机评分">3.5 随机评分</h5>
<p>我们的搜索词条结果集中有很多点赞数一样的词条，在指定按点赞数排序这种方式后，有相同评分 <code>_score</code> 的文档会每次都以相同次序出现，为了提高展现率，可以引入一些随机性，保证有相同评分的文档都能有均等相似的展现机率。</p>
<p>每个用户看到不同的随机次序，但也同时希望如果是同一用户翻页浏览时，结果的相对次序能始终保持一致。这种行为被称为 一致随机（consistently random） 。</p>
<p>引用：https://www.elastic.co/guide/cn/elasticsearch/guide/current/random-scoring.html</p>
<p>以下是样例：</p>
<pre><code class="language-json">curl -XPOST '106.14.227.30: 9200/chageng/_search?pretty' -H 'Content-Type: application/json' -d '
{
  &quot;query&quot;: {
    &quot;function_score&quot;: {
      &quot;filter&quot;: {
        &quot;match&quot;: { &quot;name&quot;: &quot;小鸡快跑&quot; }
      },
      &quot;functions&quot;: [
        {
          &quot;filter&quot;: { &quot;term&quot;: { &quot;tagList&quot;: &quot;小鸡&quot; }},
          &quot;weight&quot;: 1
        },
        {
          &quot;filter&quot;: { &quot;term&quot;: { &quot;tagList&quot;: &quot;游戏&quot; }},
          &quot;weight&quot;: 2
        },
        {
          &quot;random_score&quot;: { 
            &quot;seed&quot;:  &quot;the users session id&quot; 
          }
        }
      ],
      &quot;score_mode&quot;: &quot;sum&quot;
    }
  }
}
</code></pre>
<h3 id="三-elasticsearch性能问题">三、Elasticsearch性能问题</h3>
<h4 id="1-数据预热">1. 数据预热:</h4>
<p>ES可以在查询前进行预热，将查询中十分依赖的字段的数据加载出来，可以使用Elasticsearch为类型和索引定义预热查询。</p>
<p>定义一个新的预热查询，和普通查询没什么区别，只是它存储在Elasticsearch一个特殊的名为_warmer的索引中，以下是我的预热查询。</p>
<pre><code class="language-json">curl -XPUT '106.14.227.30: 9200/chageng/_warmer?pretty' -H 'Content-Type: application/json' -d '
{
    &quot;query&quot;: {
        &quot;match_all&quot;: {}
    },
    &quot;facets&quot;: {
        &quot;warming_facet&quot;: {
            &quot;terms&quot;: {
                &quot;field&quot;: &quot;name&quot;
            }
        }
    }
}'
</code></pre>
<h4 id="2-优化索引">2. 优化索引</h4>
<p>我建立的索引，每个词条都包含较多的内容，不仅包括了该词条的基本信息（name，tag，content，view，like），还包括了从微博、B站、谷歌等地方爬取到的相关信息，每个词条中包含的数据比较多，对完整的词条建立索引，每次的查询速度与在mongodb里面检索持平，在做自动补全时能够有肉眼可见的延迟。</p>
<p>出现查询速度过慢的情况有两方面的原因。第一是建立的索引包含的内容过多，比如微博、B站的数据大约是该词条的基本信息的25倍以上，而这些微博、B站的信息我们在做检索的时候并不需要对这些字段进行检索，这些无效的信息拖累了检索速度。第二是网络传输延迟，因为我们的ES集群和我们的搜索引擎服务并不在同一个机器上面，他们之间是通过网络进行通信，由于每条词条包含数据比较大，所以如果查询结果中有上百条的数据被命中，返回这些数据时需要比较多的时间。</p>
<p>我们的解决方案是建立两个索引，第一个索引存储词条的基本信息，第二个索引存储词条的所有信息，但使用检索功能的时候，我们只需要在第一个索引中检索，将词条的基本信息返回呈现给用户，这样可以大大加快速度。为了将速度优化到极致，在不影响用户正常使用的情况下，我们又对搜索结果的数量进行了限制，每次只返回当前页面要展现的搜索条目，最快的呈现给用户结果，其余的搜索结果用异步的方式加载。当用户进入词条详细页面时，我们可以通过该词条的id，到ES中的第二个索引中查找该id词条的所有信息进行返回，这样的检索速度能够提升到28倍。</p>
<h4 id="3-优化存储">3. 优化存储</h4>
<p>上文提到索引可以存储到ES中，这样的查询效率最高，那具体的数据可以存储到MySQL、MongoDb，ES三种数据库中，考虑到我们的数据类型以json文件为主，MySQL需要建立多张表来实现关系间的映射，故不做考虑。</p>
<p>我对MongoDb存储词条的所有信息，与直接用ES存储所有的信息进行检索做了一个对比，发现两者在检索10000条数据运行时间上并没有太大差异，所以直接使用ES进行存储了所有的数据。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8Eelasticsearch%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">基于Elasticsearch集群的数据查询优化</a>
<ul>
<li><a href="#%E4%B8%80-elasticsearch%E7%9A%84%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">一、Elasticsearch的集群部署</a>
<ul>
<li><a href="#1-es%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B">1. ES概念简介</a></li>
<li><a href="#2-elsaticsearch%E9%9B%86%E7%BE%A4%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%89%E4%B8%AA%E8%8A%82%E7%82%B9">2. Elsaticsearch集群至少需要有三个节点</a>
<ul>
<li><a href="#%E4%B8%89%E4%B8%AA%E5%92%8C%E5%B0%9A%E6%8A%95%E7%A5%A8">三个和尚投票</a></li>
<li><a href="#%E4%B8%A4%E4%B8%AA%E5%92%8C%E5%B0%9A%E6%8A%95%E7%A5%A8">两个和尚投票</a></li>
<li><a href="#%E4%B8%89%E4%B8%AA%E5%92%8C%E5%B0%9A%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98">三个和尚仍然存在问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-elasticsearch%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96">二、Elasticsearch的查询参数优化</a>
<ul>
<li><a href="#1-lucene%E7%9A%84%E6%89%93%E5%88%86%E6%A8%A1%E5%9E%8B">1. Lucene的打分模型</a></li>
<li><a href="#2-%E5%88%86%E8%AF%8D%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9">2. 分词器的选择</a></li>
<li><a href="#3-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96">3. 查询语句的优化</a>
<ul>
<li><a href="#31-term-match%E4%B8%8Emulti_match">3.1 term、match与multi_match</a></li>
<li><a href="#32-%E7%BB%84%E5%90%88%E8%BF%87%E6%BB%A4%E5%99%A8bool">3.2 组合过滤器bool</a></li>
<li><a href="#33-boost%E6%9D%83%E9%87%8D%E6%8E%A7%E5%88%B6">3.3 boost权重控制</a></li>
<li><a href="#34-%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D">3.4 模糊匹配</a></li>
<li><a href="#35-%E9%9A%8F%E6%9C%BA%E8%AF%84%E5%88%86">3.5 随机评分</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-elasticsearch%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">三、Elasticsearch性能问题</a>
<ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD">1. 数据预热:</a></li>
<li><a href="#2-%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95">2. 优化索引</a></li>
<li><a href="#3-%E4%BC%98%E5%8C%96%E5%AD%98%E5%82%A8">3. 优化存储</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/yangyueren" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://yangyueren.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>木头人</span><br>Powered by Gridea</p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://yangyueren.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://yangyueren.github.io/media/scripts/clean-blog.min.js"></script> -->
  <script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://yangyueren.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://yangyueren.github.io/";
        addScript("https://yangyueren.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://yangyueren.github.io/media/scripts/tocScript.js"></script>
</body>

</html>